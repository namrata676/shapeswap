{"ast":null,"code":"import _objectSpread from\"/Users/namratapatel/upwork/SmartFinance-OmniDex/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";/* eslint-disable @typescript-eslint/no-inferrable-types *//* eslint-disable import/no-cycle */// import invariant from 'tiny-invariant'\nimport JSBI from'jsbi';import{pack,keccak256}from'@ethersproject/solidity';import{getCreate2Address}from'@ethersproject/address';import{Price}from'./fractions/price';import{TokenAmount}from'./fractions/tokenAmount';import{FACTORY_ADDRESS,INIT_CODE_HASH,MINIMUM_LIQUIDITY,ZERO,ONE,FIVE,FEES_NUMERATOR,FEES_DENOMINATOR}from'../constants';import{sqrt,parseBigintIsh}from'../utils';import{InsufficientReservesError,InsufficientInputAmountError}from'../errors';import{Token}from'./token';let PAIR_ADDRESS_CACHE={};export class Pair{static getAddress(tokenA,tokenB){var _PAIR_ADDRESS_CACHE,_PAIR_ADDRESS_CACHE$t;const tokens=tokenA.sortsBefore(tokenB)?[tokenA,tokenB]:[tokenB,tokenA];// does safety checks\nif(((_PAIR_ADDRESS_CACHE=PAIR_ADDRESS_CACHE)===null||_PAIR_ADDRESS_CACHE===void 0?void 0:(_PAIR_ADDRESS_CACHE$t=_PAIR_ADDRESS_CACHE[tokens[0].address])===null||_PAIR_ADDRESS_CACHE$t===void 0?void 0:_PAIR_ADDRESS_CACHE$t[tokens[1].address])===undefined){var _PAIR_ADDRESS_CACHE2;PAIR_ADDRESS_CACHE=_objectSpread(_objectSpread({},PAIR_ADDRESS_CACHE),{},{[tokens[0].address]:_objectSpread(_objectSpread({},(_PAIR_ADDRESS_CACHE2=PAIR_ADDRESS_CACHE)===null||_PAIR_ADDRESS_CACHE2===void 0?void 0:_PAIR_ADDRESS_CACHE2[tokens[0].address]),{},{[tokens[1].address]:getCreate2Address(FACTORY_ADDRESS,keccak256(['bytes'],[pack(['address','address'],[tokens[0].address,tokens[1].address])]),INIT_CODE_HASH)})});}return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];}constructor(tokenAmountA,tokenAmountB){this.liquidityToken=void 0;this.tokenAmounts=void 0;const tokenAmounts=tokenAmountA.token.sortsBefore(tokenAmountB.token)// does safety checks\n?[tokenAmountA,tokenAmountB]:[tokenAmountB,tokenAmountA];this.liquidityToken=new Token(tokenAmounts[0].token.chainId,Pair.getAddress(tokenAmounts[0].token,tokenAmounts[1].token),18,'Cake-LP','Pancake LPs');this.tokenAmounts=tokenAmounts;}/**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */involvesToken(token){return token.equals(this.token0)||token.equals(this.token1);}/**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */get token0Price(){return new Price(this.token0,this.token1,this.tokenAmounts[0].raw,this.tokenAmounts[1].raw);}/**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */get token1Price(){return new Price(this.token1,this.token0,this.tokenAmounts[1].raw,this.tokenAmounts[0].raw);}/**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */priceOf(token){// invariant(this.involvesToken(token), 'TOKEN')\nreturn token.equals(this.token0)?this.token0Price:this.token1Price;}/**\n   * Returns the chain ID of the tokens in the pair.\n   */get chainId(){return this.token0.chainId;}get token0(){return this.tokenAmounts[0].token;}get token1(){return this.tokenAmounts[1].token;}get reserve0(){return this.tokenAmounts[0];}get reserve1(){return this.tokenAmounts[1];}reserveOf(token){// invariant(this.involvesToken(token), 'TOKEN')\nreturn token.equals(this.token0)?this.reserve0:this.reserve1;}getOutputAmount(inputAmount){// invariant(this.involvesToken(inputAmount.token), 'TOKEN')\nif(JSBI.equal(this.reserve0.raw,ZERO)||JSBI.equal(this.reserve1.raw,ZERO)){throw new InsufficientReservesError();}const inputReserve=this.reserveOf(inputAmount.token);const outputReserve=this.reserveOf(inputAmount.token.equals(this.token0)?this.token1:this.token0);const inputAmountWithFee=JSBI.multiply(inputAmount.raw,FEES_NUMERATOR);const numerator=JSBI.multiply(inputAmountWithFee,outputReserve.raw);const denominator=JSBI.add(JSBI.multiply(inputReserve.raw,FEES_DENOMINATOR),inputAmountWithFee);const outputAmount=new TokenAmount(inputAmount.token.equals(this.token0)?this.token1:this.token0,JSBI.divide(numerator,denominator));if(JSBI.equal(outputAmount.raw,ZERO)){throw new InsufficientInputAmountError();}return[outputAmount,new Pair(inputReserve.add(inputAmount),outputReserve.subtract(outputAmount))];}getInputAmount(outputAmount){// invariant(this.involvesToken(outputAmount.token), 'TOKEN')\nif(JSBI.equal(this.reserve0.raw,ZERO)||JSBI.equal(this.reserve1.raw,ZERO)||JSBI.greaterThanOrEqual(outputAmount.raw,this.reserveOf(outputAmount.token).raw)){throw new InsufficientReservesError();}const outputReserve=this.reserveOf(outputAmount.token);const inputReserve=this.reserveOf(outputAmount.token.equals(this.token0)?this.token1:this.token0);const numerator=JSBI.multiply(JSBI.multiply(inputReserve.raw,outputAmount.raw),FEES_DENOMINATOR);const denominator=JSBI.multiply(JSBI.subtract(outputReserve.raw,outputAmount.raw),FEES_NUMERATOR);const inputAmount=new TokenAmount(outputAmount.token.equals(this.token0)?this.token1:this.token0,JSBI.add(JSBI.divide(numerator,denominator),ONE));return[inputAmount,new Pair(inputReserve.add(inputAmount),outputReserve.subtract(outputAmount))];}getLiquidityMinted(totalSupply,tokenAmountA,tokenAmountB){// invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\nconst tokenAmounts=tokenAmountA.token.sortsBefore(tokenAmountB.token)// does safety checks\n?[tokenAmountA,tokenAmountB]:[tokenAmountB,tokenAmountA];// invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\nlet liquidity;if(JSBI.equal(totalSupply.raw,ZERO)){liquidity=JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw,tokenAmounts[1].raw)),MINIMUM_LIQUIDITY);}else{const amount0=JSBI.divide(JSBI.multiply(tokenAmounts[0].raw,totalSupply.raw),this.reserve0.raw);const amount1=JSBI.divide(JSBI.multiply(tokenAmounts[1].raw,totalSupply.raw),this.reserve1.raw);liquidity=JSBI.lessThanOrEqual(amount0,amount1)?amount0:amount1;}if(!JSBI.greaterThan(liquidity,ZERO)){throw new InsufficientInputAmountError();}return new TokenAmount(this.liquidityToken,liquidity);}getLiquidityValue(token,totalSupply,liquidity){let feeOn=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;let kLast=arguments.length>4?arguments[4]:undefined;// invariant(this.involvesToken(token), 'TOKEN')\n// invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n// invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n// invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\nlet totalSupplyAdjusted;if(!feeOn){totalSupplyAdjusted=totalSupply;}else{// invariant(!!kLast, 'K_LAST')\nconst kLastParsed=parseBigintIsh(kLast);if(!JSBI.equal(kLastParsed,ZERO)){const rootK=sqrt(JSBI.multiply(this.reserve0.raw,this.reserve1.raw));const rootKLast=sqrt(kLastParsed);if(JSBI.greaterThan(rootK,rootKLast)){const numerator=JSBI.multiply(totalSupply.raw,JSBI.subtract(rootK,rootKLast));const denominator=JSBI.add(JSBI.multiply(rootK,FIVE),rootKLast);const feeLiquidity=JSBI.divide(numerator,denominator);totalSupplyAdjusted=totalSupply.add(new TokenAmount(this.liquidityToken,feeLiquidity));}else{totalSupplyAdjusted=totalSupply;}}else{totalSupplyAdjusted=totalSupply;}}return new TokenAmount(token,JSBI.divide(JSBI.multiply(liquidity.raw,this.reserveOf(token).raw),totalSupplyAdjusted.raw));}}","map":{"version":3,"names":["JSBI","pack","keccak256","getCreate2Address","Price","TokenAmount","FACTORY_ADDRESS","INIT_CODE_HASH","MINIMUM_LIQUIDITY","ZERO","ONE","FIVE","FEES_NUMERATOR","FEES_DENOMINATOR","sqrt","parseBigintIsh","InsufficientReservesError","InsufficientInputAmountError","Token","PAIR_ADDRESS_CACHE","Pair","getAddress","tokenA","tokenB","_PAIR_ADDRESS_CACHE","_PAIR_ADDRESS_CACHE$t","tokens","sortsBefore","address","undefined","_PAIR_ADDRESS_CACHE2","_objectSpread","constructor","tokenAmountA","tokenAmountB","liquidityToken","tokenAmounts","token","chainId","involvesToken","equals","token0","token1","token0Price","raw","token1Price","priceOf","reserve0","reserve1","reserveOf","getOutputAmount","inputAmount","equal","inputReserve","outputReserve","inputAmountWithFee","multiply","numerator","denominator","add","outputAmount","divide","subtract","getInputAmount","greaterThanOrEqual","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","lessThanOrEqual","greaterThan","getLiquidityValue","feeOn","arguments","length","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/entities/pair.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable import/no-cycle */\n// import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  FEES_NUMERATOR,\n  FEES_DENOMINATOR,\n  ChainId,\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  \n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS,\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH\n          ),\n        },\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'Cake-LP',\n      'Pancake LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    // invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    // invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    // invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    // invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    // invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      // invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}