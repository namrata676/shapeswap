{"ast":null,"code":"/* eslint-disable default-case *//* eslint-disable @typescript-eslint/no-empty-function *//* eslint-disable no-useless-constructor */// import invariant from 'tiny-invariant'\nimport{TradeType}from'./constants';import{validateAndParseAddress}from'./utils';import{ETHER}from'./entities';/**\n * Options for producing the arguments to send call to the router.\n *//**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */function toHex(currencyAmount){return\"0x\".concat(currencyAmount.raw.toString(16));}const ZERO_HEX='0x0';/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */export class Router{/**\n   * Cannot be constructed.\n   */constructor(){}/**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */// eslint-disable-next-line lines-between-class-members\nstatic swapCallParameters(trade,options){const etherIn=trade.inputAmount.currency===ETHER;const etherOut=trade.outputAmount.currency===ETHER;// the router does not support both ether in and out\n// invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n// invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\nconst to=validateAndParseAddress(options.recipient);const amountIn=toHex(trade.maximumAmountIn(options.allowedSlippage));const amountOut=toHex(trade.minimumAmountOut(options.allowedSlippage));const path=trade.route.path.map(token=>token.address);const deadline='ttl'in options?\"0x\".concat((Math.floor(new Date().getTime()/1000)+options.ttl).toString(16)):\"0x\".concat(options.deadline.toString(16));const useFeeOnTransfer=Boolean(options.feeOnTransfer);let methodName;let args;let value;switch(trade.tradeType){case TradeType.EXACT_INPUT:if(etherIn){methodName=useFeeOnTransfer?'swapExactETHForTokensSupportingFeeOnTransferTokens':'swapExactETHForTokens';// (uint amountOutMin, address[] calldata path, address to, uint deadline)\nargs=[amountOut,path,to,deadline];value=amountIn;}else if(etherOut){methodName=useFeeOnTransfer?'swapExactTokensForETHSupportingFeeOnTransferTokens':'swapExactTokensForETH';// (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\nargs=[amountIn,amountOut,path,to,deadline];value=ZERO_HEX;}else{methodName=useFeeOnTransfer?'swapExactTokensForTokensSupportingFeeOnTransferTokens':'swapExactTokensForTokens';// (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\nargs=[amountIn,amountOut,path,to,deadline];value=ZERO_HEX;}break;case TradeType.EXACT_OUTPUT:// invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\nif(etherIn){methodName='swapETHForExactTokens';// (uint amountOut, address[] calldata path, address to, uint deadline)\nargs=[amountOut,path,to,deadline];value=amountIn;}else if(etherOut){methodName='swapTokensForExactETH';// (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\nargs=[amountOut,amountIn,path,to,deadline];value=ZERO_HEX;}else{methodName='swapTokensForExactTokens';// (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\nargs=[amountOut,amountIn,path,to,deadline];value=ZERO_HEX;}break;}return{methodName,args,value};}}","map":{"version":3,"names":["TradeType","validateAndParseAddress","ETHER","toHex","currencyAmount","concat","raw","toString","ZERO_HEX","Router","constructor","swapCallParameters","trade","options","etherIn","inputAmount","currency","etherOut","outputAmount","to","recipient","amountIn","maximumAmountIn","allowedSlippage","amountOut","minimumAmountOut","path","route","map","token","address","deadline","Math","floor","Date","getTime","ttl","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args","value","tradeType","EXACT_INPUT","EXACT_OUTPUT"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/router.ts"],"sourcesContent":["/* eslint-disable default-case */\n/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable no-useless-constructor */\n// import invariant from 'tiny-invariant'\nimport { TradeType } from './constants'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, ETHER, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  // eslint-disable-next-line lines-between-class-members\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    const etherIn = trade.inputAmount.currency === ETHER\n    const etherOut = trade.outputAmount.currency === ETHER\n    // the router does not support both ether in and out\n    // invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    // invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        // invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"mappings":"AAAA,iCACA,yDACA,2CACA;AACA,OAASA,SAAS,KAAQ,aAAa,CACvC,OAASC,uBAAuB,KAAQ,SAAS,CACjD,OAAyBC,KAAK,KAAwB,YAAY,CAElE;AACA;AACA,GA+BA;AACA;AACA,GAgBA,QAAS,CAAAC,KAAKA,CAACC,cAA8B,CAAE,CAC7C,WAAAC,MAAA,CAAYD,cAAc,CAACE,GAAG,CAACC,QAAQ,CAAC,EAAE,CAAC,EAC7C,CAEA,KAAM,CAAAC,QAAQ,CAAG,KAAK,CAEtB;AACA;AACA,GACA,MAAO,MAAe,CAAAC,MAAO,CAC3B;AACF;AACA,KACUC,WAAWA,CAAA,CAAG,CAAC,CACvB;AACF;AACA;AACA;AACA,KACE;AACA,MAAc,CAAAC,kBAAkBA,CAACC,KAAY,CAAEC,OAA4C,CAAkB,CAC3G,KAAM,CAAAC,OAAO,CAAGF,KAAK,CAACG,WAAW,CAACC,QAAQ,GAAKd,KAAK,CACpD,KAAM,CAAAe,QAAQ,CAAGL,KAAK,CAACM,YAAY,CAACF,QAAQ,GAAKd,KAAK,CACtD;AACA;AACA;AAEA,KAAM,CAAAiB,EAAU,CAAGlB,uBAAuB,CAACY,OAAO,CAACO,SAAS,CAAC,CAC7D,KAAM,CAAAC,QAAgB,CAAGlB,KAAK,CAACS,KAAK,CAACU,eAAe,CAACT,OAAO,CAACU,eAAe,CAAC,CAAC,CAC9E,KAAM,CAAAC,SAAiB,CAAGrB,KAAK,CAACS,KAAK,CAACa,gBAAgB,CAACZ,OAAO,CAACU,eAAe,CAAC,CAAC,CAChF,KAAM,CAAAG,IAAc,CAAGd,KAAK,CAACe,KAAK,CAACD,IAAI,CAACE,GAAG,CAAEC,KAAK,EAAKA,KAAK,CAACC,OAAO,CAAC,CACrE,KAAM,CAAAC,QAAQ,CACZ,KAAK,EAAI,CAAAlB,OAAO,MAAAR,MAAA,CACP,CAAC2B,IAAI,CAACC,KAAK,CAAC,GAAI,CAAAC,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,CAAG,IAAI,CAAC,CAAGtB,OAAO,CAACuB,GAAG,EAAE7B,QAAQ,CAAC,EAAE,CAAC,OAAAF,MAAA,CACpEQ,OAAO,CAACkB,QAAQ,CAACxB,QAAQ,CAAC,EAAE,CAAC,CAAE,CAE1C,KAAM,CAAA8B,gBAAgB,CAAGC,OAAO,CAACzB,OAAO,CAAC0B,aAAa,CAAC,CAEvD,GAAI,CAAAC,UAAkB,CACtB,GAAI,CAAAC,IAA2B,CAC/B,GAAI,CAAAC,KAAa,CACjB,OAAQ9B,KAAK,CAAC+B,SAAS,EACrB,IAAK,CAAA3C,SAAS,CAAC4C,WAAW,CACxB,GAAI9B,OAAO,CAAE,CACX0B,UAAU,CAAGH,gBAAgB,CAAG,oDAAoD,CAAG,uBAAuB,CAC9G;AACAI,IAAI,CAAG,CAACjB,SAAS,CAAEE,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CACtCW,KAAK,CAAGrB,QAAQ,CAClB,CAAC,IAAM,IAAIJ,QAAQ,CAAE,CACnBuB,UAAU,CAAGH,gBAAgB,CAAG,oDAAoD,CAAG,uBAAuB,CAC9G;AACAI,IAAI,CAAG,CAACpB,QAAQ,CAAEG,SAAS,CAAEE,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CAChDW,KAAK,CAAGlC,QAAQ,CAClB,CAAC,IAAM,CACLgC,UAAU,CAAGH,gBAAgB,CACzB,uDAAuD,CACvD,0BAA0B,CAC9B;AACAI,IAAI,CAAG,CAACpB,QAAQ,CAAEG,SAAS,CAAEE,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CAChDW,KAAK,CAAGlC,QAAQ,CAClB,CACA,MACF,IAAK,CAAAR,SAAS,CAAC6C,YAAY,CACzB;AACA,GAAI/B,OAAO,CAAE,CACX0B,UAAU,CAAG,uBAAuB,CACpC;AACAC,IAAI,CAAG,CAACjB,SAAS,CAAEE,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CACtCW,KAAK,CAAGrB,QAAQ,CAClB,CAAC,IAAM,IAAIJ,QAAQ,CAAE,CACnBuB,UAAU,CAAG,uBAAuB,CACpC;AACAC,IAAI,CAAG,CAACjB,SAAS,CAAEH,QAAQ,CAAEK,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CAChDW,KAAK,CAAGlC,QAAQ,CAClB,CAAC,IAAM,CACLgC,UAAU,CAAG,0BAA0B,CACvC;AACAC,IAAI,CAAG,CAACjB,SAAS,CAAEH,QAAQ,CAAEK,IAAI,CAAEP,EAAE,CAAEY,QAAQ,CAAC,CAChDW,KAAK,CAAGlC,QAAQ,CAClB,CACA,MACJ,CACA,MAAO,CACLgC,UAAU,CACVC,IAAI,CACJC,KACF,CAAC,CACH,CACF","ignoreList":[]},"metadata":{},"sourceType":"module"}