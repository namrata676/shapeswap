{"ast":null,"code":"import { ethers } from 'ethers';\nimport { getMulticallContract } from 'utils/contractHelpers';\nconst multicall = async (abi, calls) => {\n  // try {\n  const multi = getMulticallContract();\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n  const {\n    returnData\n  } = await multi.aggregate(calldata);\n  const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call));\n  return res;\n  // } catch (error) {\n\n  // throw new Error(error)\n  // }\n};\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\nexport const multicallv2 = async (abi, calls, options = {\n  requireSuccess: true\n}) => {\n  const {\n    requireSuccess\n  } = options;\n  const multi = getMulticallContract();\n  const itf = new ethers.utils.Interface(abi);\n  const calldata = calls.map(call => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)]);\n  const returnData = await multi.tryAggregate(requireSuccess, calldata);\n  const res = returnData.map((call, i) => {\n    const [result, data] = call;\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null;\n  });\n  return res;\n};\nexport default multicall;","map":{"version":3,"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","aggregate","res","i","decodeFunctionResult","multicallv2","options","requireSuccess","tryAggregate","result","data"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/utils/multicall.ts"],"sourcesContent":["import { ethers } from 'ethers'\nimport { getMulticallContract } from 'utils/contractHelpers'\nimport { MultiCallResponse } from './types'\n\nexport interface Call {\n  address: string // Address of the contract\n  name: string // Function name on the contract (example: balanceOf)\n  params?: any[] // Function params\n}\n\ninterface MulticallOptions {\n  requireSuccess?: boolean\n}\n\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\n  // try {\n    const multi = getMulticallContract()\n    const itf = new ethers.utils.Interface(abi)\n\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n    const { returnData } = await multi.aggregate(calldata)\n\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\n\n    return res\n  // } catch (error) {\n    \n    // throw new Error(error)\n  // }\n}\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\nexport const multicallv2 = async <T = any>(\n  abi: any[],\n  calls: Call[],\n  options: MulticallOptions = { requireSuccess: true },\n): Promise<MultiCallResponse<T>> => {\n  const { requireSuccess } = options\n  const multi = getMulticallContract()\n  const itf = new ethers.utils.Interface(abi)\n\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\n  const res = returnData.map((call, i) => {\n    const [result, data] = call\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\n  })\n\n  return res\n}\n\nexport default multicall\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAC/B,SAASC,oBAAoB,QAAQ,uBAAuB;AAa5D,MAAMC,SAAS,GAAG,MAAAA,CAAgBC,GAAU,EAAEC,KAAa,KAAiB;EAC1E;EACE,MAAMC,KAAK,GAAGJ,oBAAoB,CAAC,CAAC;EACpC,MAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC;EAE3C,MAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,EAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,EAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC;EAClH,MAAM;IAAEC;EAAW,CAAC,GAAG,MAAMZ,KAAK,CAACa,SAAS,CAACT,QAAQ,CAAC;EAEtD,MAAMU,GAAG,GAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,EAAES,CAAC,KAAKd,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,EAAEJ,IAAI,CAAC,CAAC;EAEtF,OAAOQ,GAAG;EACZ;;EAEE;EACF;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,WAAW,GAAG,MAAAA,CACzBnB,GAAU,EACVC,KAAa,EACbmB,OAAyB,GAAG;EAAEC,cAAc,EAAE;AAAK,CAAC,KAClB;EAClC,MAAM;IAAEA;EAAe,CAAC,GAAGD,OAAO;EAClC,MAAMlB,KAAK,GAAGJ,oBAAoB,CAAC,CAAC;EACpC,MAAMK,GAAG,GAAG,IAAIN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC;EAE3C,MAAMM,QAAQ,GAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,IAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,EAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,EAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC;EAClH,MAAMC,UAAU,GAAG,MAAMZ,KAAK,CAACoB,YAAY,CAACD,cAAc,EAAEf,QAAQ,CAAC;EACrE,MAAMU,GAAG,GAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,EAAES,CAAC,KAAK;IACtC,MAAM,CAACM,MAAM,EAAEC,IAAI,CAAC,GAAGhB,IAAI;IAC3B,OAAOe,MAAM,GAAGpB,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,EAAEY,IAAI,CAAC,GAAG,IAAI;EACtE,CAAC,CAAC;EAEF,OAAOR,GAAG;AACZ,CAAC;AAED,eAAejB,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}