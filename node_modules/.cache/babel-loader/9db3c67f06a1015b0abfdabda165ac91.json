{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable import/no-cycle */\n// import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi';\nimport { pack, keccak256 } from '@ethersproject/solidity';\nimport { getCreate2Address } from '@ethersproject/address';\nimport { Price } from './fractions/price';\nimport { TokenAmount } from './fractions/tokenAmount';\nimport { FACTORY_ADDRESS, INIT_CODE_HASH, MINIMUM_LIQUIDITY, ZERO, ONE, FIVE, FEES_NUMERATOR, FEES_DENOMINATOR } from '../constants';\nimport { sqrt, parseBigintIsh } from '../utils';\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors';\nimport { Token } from './token';\nlet PAIR_ADDRESS_CACHE = {};\nexport class Pair {\n  static getAddress(tokenA, tokenB) {\n    var _PAIR_ADDRESS_CACHE, _PAIR_ADDRESS_CACHE$t;\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA]; // does safety checks\n\n    if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE === void 0 ? void 0 : (_PAIR_ADDRESS_CACHE$t = _PAIR_ADDRESS_CACHE[tokens[0].address]) === null || _PAIR_ADDRESS_CACHE$t === void 0 ? void 0 : _PAIR_ADDRESS_CACHE$t[tokens[1].address]) === undefined) {\n      var _PAIR_ADDRESS_CACHE2;\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...((_PAIR_ADDRESS_CACHE2 = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE2 === void 0 ? void 0 : _PAIR_ADDRESS_CACHE2[tokens[0].address]),\n          [tokens[1].address]: getCreate2Address(FACTORY_ADDRESS, keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]), INIT_CODE_HASH)\n        }\n      };\n    }\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];\n  }\n  constructor(tokenAmountA, tokenAmountB) {\n    this.liquidityToken = void 0;\n    this.tokenAmounts = void 0;\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, 'Cake-LP', 'Pancake LPs');\n    this.tokenAmounts = tokenAmounts;\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  involvesToken(token) {\n    return token.equals(this.token0) || token.equals(this.token1);\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  get token0Price() {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  get token1Price() {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  priceOf(token) {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price;\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  get chainId() {\n    return this.token0.chainId;\n  }\n  get token0() {\n    return this.tokenAmounts[0].token;\n  }\n  get token1() {\n    return this.tokenAmounts[1].token;\n  }\n  get reserve0() {\n    return this.tokenAmounts[0];\n  }\n  get reserve1() {\n    return this.tokenAmounts[1];\n  }\n  reserveOf(token) {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1;\n  }\n  getOutputAmount(inputAmount) {\n    // invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError();\n    }\n    const inputReserve = this.reserveOf(inputAmount.token);\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR);\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw);\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee);\n    const outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getInputAmount(outputAmount) {\n    // invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO) || JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {\n      throw new InsufficientReservesError();\n    }\n    const outputReserve = this.reserveOf(outputAmount.token);\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR);\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR);\n    const inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];\n  }\n  getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n    ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];\n    // invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity;\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError();\n    }\n    return new TokenAmount(this.liquidityToken, liquidity);\n  }\n  getLiquidityValue(token, totalSupply, liquidity) {\n    let feeOn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let kLast = arguments.length > 4 ? arguments[4] : undefined;\n    // invariant(this.involvesToken(token), 'TOKEN')\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    // invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    // invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted;\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply;\n    } else {\n      // invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast);\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw));\n        const rootKLast = sqrt(kLastParsed);\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast));\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);\n          const feeLiquidity = JSBI.divide(numerator, denominator);\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));\n        } else {\n          totalSupplyAdjusted = totalSupply;\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply;\n      }\n    }\n    return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));\n  }\n}","map":{"version":3,"names":["JSBI","pack","keccak256","getCreate2Address","Price","TokenAmount","FACTORY_ADDRESS","INIT_CODE_HASH","MINIMUM_LIQUIDITY","ZERO","ONE","FIVE","FEES_NUMERATOR","FEES_DENOMINATOR","sqrt","parseBigintIsh","InsufficientReservesError","InsufficientInputAmountError","Token","PAIR_ADDRESS_CACHE","Pair","getAddress","tokenA","tokenB","tokens","sortsBefore","address","undefined","constructor","tokenAmountA","tokenAmountB","liquidityToken","tokenAmounts","token","chainId","involvesToken","equals","token0","token1","token0Price","raw","token1Price","priceOf","reserve0","reserve1","reserveOf","getOutputAmount","inputAmount","equal","inputReserve","outputReserve","inputAmountWithFee","multiply","numerator","denominator","add","outputAmount","divide","subtract","getInputAmount","greaterThanOrEqual","getLiquidityMinted","totalSupply","liquidity","amount0","amount1","lessThanOrEqual","greaterThan","getLiquidityValue","feeOn","kLast","totalSupplyAdjusted","kLastParsed","rootK","rootKLast","feeLiquidity"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/entities/pair.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-inferrable-types */\n/* eslint-disable import/no-cycle */\n// import invariant from 'tiny-invariant'\nimport JSBI from 'jsbi'\nimport { pack, keccak256 } from '@ethersproject/solidity'\nimport { getCreate2Address } from '@ethersproject/address'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\n\nimport {\n  BigintIsh,\n  FACTORY_ADDRESS,\n  INIT_CODE_HASH,\n  MINIMUM_LIQUIDITY,\n  ZERO,\n  ONE,\n  FIVE,\n  FEES_NUMERATOR,\n  FEES_DENOMINATOR,\n  ChainId,\n} from '../constants'\nimport { sqrt, parseBigintIsh } from '../utils'\nimport { InsufficientReservesError, InsufficientInputAmountError } from '../errors'\nimport { Token } from './token'\n\nlet PAIR_ADDRESS_CACHE: { [token0Address: string]: { [token1Address: string]: string } } = {}\n\nexport class Pair {\n  public readonly liquidityToken: Token\n  \n  private readonly tokenAmounts: [TokenAmount, TokenAmount]\n\n  public static getAddress(tokenA: Token, tokenB: Token): string {\n    const tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA] // does safety checks\n\n    if (PAIR_ADDRESS_CACHE?.[tokens[0].address]?.[tokens[1].address] === undefined) {\n      PAIR_ADDRESS_CACHE = {\n        ...PAIR_ADDRESS_CACHE,\n        [tokens[0].address]: {\n          ...PAIR_ADDRESS_CACHE?.[tokens[0].address],\n          [tokens[1].address]: getCreate2Address(\n            FACTORY_ADDRESS,\n            keccak256(['bytes'], [pack(['address', 'address'], [tokens[0].address, tokens[1].address])]),\n            INIT_CODE_HASH\n          ),\n        },\n      }\n    }\n\n    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address]\n  }\n\n  public constructor(tokenAmountA: TokenAmount, tokenAmountB: TokenAmount) {\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    this.liquidityToken = new Token(\n      tokenAmounts[0].token.chainId,\n      Pair.getAddress(tokenAmounts[0].token, tokenAmounts[1].token),\n      18,\n      'Cake-LP',\n      'Pancake LPs'\n    )\n    this.tokenAmounts = tokenAmounts as [TokenAmount, TokenAmount]\n  }\n\n  /**\n   * Returns true if the token is either token0 or token1\n   * @param token to check\n   */\n  public involvesToken(token: Token): boolean {\n    return token.equals(this.token0) || token.equals(this.token1)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token0, i.e. the ratio of reserve1 to reserve0\n   */\n  public get token0Price(): Price {\n    return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw)\n  }\n\n  /**\n   * Returns the current mid price of the pair in terms of token1, i.e. the ratio of reserve0 to reserve1\n   */\n  public get token1Price(): Price {\n    return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw)\n  }\n\n  /**\n   * Return the price of the given token in terms of the other token in the pair.\n   * @param token token to return price of\n   */\n  public priceOf(token: Token): Price {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.token0Price : this.token1Price\n  }\n\n  /**\n   * Returns the chain ID of the tokens in the pair.\n   */\n  public get chainId(): ChainId {\n    return this.token0.chainId\n  }\n\n  public get token0(): Token {\n    return this.tokenAmounts[0].token\n  }\n\n  public get token1(): Token {\n    return this.tokenAmounts[1].token\n  }\n\n  public get reserve0(): TokenAmount {\n    return this.tokenAmounts[0]\n  }\n\n  public get reserve1(): TokenAmount {\n    return this.tokenAmounts[1]\n  }\n\n  public reserveOf(token: Token): TokenAmount {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    return token.equals(this.token0) ? this.reserve0 : this.reserve1\n  }\n\n  public getOutputAmount(inputAmount: TokenAmount): [TokenAmount, Pair] {\n    // invariant(this.involvesToken(inputAmount.token), 'TOKEN')\n    if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {\n      throw new InsufficientReservesError()\n    }\n    const inputReserve = this.reserveOf(inputAmount.token)\n    const outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR)\n    const numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw)\n    const denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee)\n    const outputAmount = new TokenAmount(\n      inputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.divide(numerator, denominator)\n    )\n    if (JSBI.equal(outputAmount.raw, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return [outputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getInputAmount(outputAmount: TokenAmount): [TokenAmount, Pair] {\n    // invariant(this.involvesToken(outputAmount.token), 'TOKEN')\n    if (\n      JSBI.equal(this.reserve0.raw, ZERO) ||\n      JSBI.equal(this.reserve1.raw, ZERO) ||\n      JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)\n    ) {\n      throw new InsufficientReservesError()\n    }\n\n    const outputReserve = this.reserveOf(outputAmount.token)\n    const inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0)\n    const numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR)\n    const denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR)\n    const inputAmount = new TokenAmount(\n      outputAmount.token.equals(this.token0) ? this.token1 : this.token0,\n      JSBI.add(JSBI.divide(numerator, denominator), ONE)\n    )\n    return [inputAmount, new Pair(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))]\n  }\n\n  public getLiquidityMinted(\n    totalSupply: TokenAmount,\n    tokenAmountA: TokenAmount,\n    tokenAmountB: TokenAmount\n  ): TokenAmount {\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'LIQUIDITY')\n    const tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) // does safety checks\n      ? [tokenAmountA, tokenAmountB]\n      : [tokenAmountB, tokenAmountA]\n    // invariant(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1), 'TOKEN')\n\n    let liquidity: JSBI\n    if (JSBI.equal(totalSupply.raw, ZERO)) {\n      liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY)\n    } else {\n      const amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw)\n      const amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw)\n      liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1\n    }\n    if (!JSBI.greaterThan(liquidity, ZERO)) {\n      throw new InsufficientInputAmountError()\n    }\n    return new TokenAmount(this.liquidityToken, liquidity)\n  }\n\n  public getLiquidityValue(\n    token: Token,\n    totalSupply: TokenAmount,\n    liquidity: TokenAmount,\n    feeOn: boolean = false,\n    kLast?: BigintIsh\n  ): TokenAmount {\n    // invariant(this.involvesToken(token), 'TOKEN')\n    // invariant(totalSupply.token.equals(this.liquidityToken), 'TOTAL_SUPPLY')\n    // invariant(liquidity.token.equals(this.liquidityToken), 'LIQUIDITY')\n    // invariant(JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw), 'LIQUIDITY')\n\n    let totalSupplyAdjusted: TokenAmount\n    if (!feeOn) {\n      totalSupplyAdjusted = totalSupply\n    } else {\n      // invariant(!!kLast, 'K_LAST')\n      const kLastParsed = parseBigintIsh(kLast)\n      if (!JSBI.equal(kLastParsed, ZERO)) {\n        const rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw))\n        const rootKLast = sqrt(kLastParsed)\n        if (JSBI.greaterThan(rootK, rootKLast)) {\n          const numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast))\n          const denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast)\n          const feeLiquidity = JSBI.divide(numerator, denominator)\n          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity))\n        } else {\n          totalSupplyAdjusted = totalSupply\n        }\n      } else {\n        totalSupplyAdjusted = totalSupply\n      }\n    }\n\n    return new TokenAmount(\n      token,\n      JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n    )\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}