{"ast":null,"code":"/* eslint-disable consistent-return *//* eslint-disable @typescript-eslint/no-non-null-assertion *//* eslint-disable no-bitwise *//* eslint-disable one-var *//* eslint-disable no-else-return */// import invariant from 'tiny-invariant'\nimport warning from'tiny-warning';import JSBI from'jsbi';import{getAddress}from'@ethersproject/address';import{ZERO,ONE,TWO,THREE,SolidityType}from'./constants';export function validateSolidityTypeInstance(value,solidityType){// invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n// invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}// warns if addresses are not checksummed\nexport function validateAndParseAddress(address){try{const checksummedAddress=getAddress(address);warning(address===checksummedAddress,\"\".concat(address,\" is not checksummed.\"));return checksummedAddress;}catch(error){// invariant(false, `${address} is not a valid address.`)\n}}export function parseBigintIsh(bigintIsh){return bigintIsh instanceof JSBI?bigintIsh:typeof bigintIsh==='bigint'?JSBI.BigInt(bigintIsh.toString()):JSBI.BigInt(bigintIsh);}// mock the on-chain sqrt function\nexport function sqrt(y){validateSolidityTypeInstance(y,SolidityType.uint256);let z=ZERO;let x;if(JSBI.greaterThan(y,THREE)){z=y;x=JSBI.add(JSBI.divide(y,TWO),ONE);while(JSBI.lessThan(x,z)){z=x;x=JSBI.divide(JSBI.add(JSBI.divide(y,x),x),TWO);}}else if(JSBI.notEqual(y,ZERO)){z=ONE;}return z;}// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert(items,add,maxSize,comparator){// short circuit first item add\nif(items.length===0){items.push(add);return null;}else{const isFull=items.length===maxSize;// short circuit if full and the additional item does not come before the last item\nif(isFull&&comparator(items[items.length-1],add)<=0){return add;}let lo=0,hi=items.length;while(lo<hi){const mid=lo+hi>>>1;if(comparator(items[mid],add)<=0){lo=mid+1;}else{hi=mid;}}items.splice(lo,0,add);return isFull?items.pop():null;}}","map":{"version":3,"names":["warning","JSBI","getAddress","ZERO","ONE","TWO","THREE","SolidityType","validateSolidityTypeInstance","value","solidityType","validateAndParseAddress","address","checksummedAddress","concat","error","parseBigintIsh","bigintIsh","BigInt","toString","sqrt","y","uint256","z","x","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/utils.ts"],"sourcesContent":["/* eslint-disable consistent-return */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable no-bitwise */\n/* eslint-disable one-var */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  // invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  // invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    // invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}