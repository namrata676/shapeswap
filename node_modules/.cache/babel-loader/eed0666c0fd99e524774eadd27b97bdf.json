{"ast":null,"code":"import{useCallback,useContext,useEffect}from\"react\";import get from\"lodash/get\";import{Context}from\"./ModalContext\";const useModal=function(modal){let closeOnOverlayClick=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;let updateOnPropsChange=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;let modalId=arguments.length>3&&arguments[3]!==undefined?arguments[3]:\"defaultNodeId\";const{isOpen,nodeId,modalNode,setModalNode,onPresent,onDismiss,setCloseOnOverlayClick}=useContext(Context);const onPresentCallback=useCallback(()=>{onPresent(modal,modalId);},[modal,modalId,onPresent]);// Updates the \"modal\" component if props are changed\n// Use carefully since it might result in unnecessary rerenders\n// Typically if modal is staic there is no need for updates, use when you expect props to change\nuseEffect(()=>{// NodeId is needed in case there are 2 useModal hooks on the same page and one has updateOnPropsChange\nif(updateOnPropsChange&&isOpen&&nodeId===modalId){const modalProps=get(modal,\"props\");const oldModalProps=get(modalNode,\"props\");// Note: I tried to use lodash isEqual to compare props but it is giving false-negatives too easily\n// For example ConfirmSwapModal in exchange has ~500 lines prop object that stringifies to same string\n// and online diff checker says both objects are identical but lodash isEqual thinks they are different\n// Do not try to replace JSON.stringify with isEqual, high risk of infinite rerenders\n// TODO: Find a good way to handle modal updates, this whole flow is just backwards-compatible workaround,\n// would be great to simplify the logic here\nif(modalProps&&oldModalProps&&JSON.stringify(modalProps)!==JSON.stringify(oldModalProps)){setModalNode(modal);}}},[updateOnPropsChange,nodeId,modalId,isOpen,modal,modalNode,setModalNode]);useEffect(()=>{setCloseOnOverlayClick(closeOnOverlayClick);},[closeOnOverlayClick,setCloseOnOverlayClick]);return[onPresentCallback,onDismiss];};export default useModal;","map":{"version":3,"names":["useCallback","useContext","useEffect","get","Context","useModal","modal","closeOnOverlayClick","arguments","length","undefined","updateOnPropsChange","modalId","isOpen","nodeId","modalNode","setModalNode","onPresent","onDismiss","setCloseOnOverlayClick","onPresentCallback","modalProps","oldModalProps","JSON","stringify"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/uikit/widgets/TokenModal/useModal.ts"],"sourcesContent":["import React, { useCallback, useContext, useEffect } from \"react\";\nimport get from \"lodash/get\";\nimport { Context } from \"./ModalContext\";\nimport { Handler } from \"./types\";\n\nconst useModal = (\n  modal: React.ReactNode,\n  closeOnOverlayClick = true,\n  updateOnPropsChange = false,\n  modalId = \"defaultNodeId\"\n): [Handler, Handler] => {\n  const { isOpen, nodeId, modalNode, setModalNode, onPresent, onDismiss, setCloseOnOverlayClick } = useContext(Context);\n  const onPresentCallback = useCallback(() => {\n    onPresent(modal, modalId);\n  }, [modal, modalId, onPresent]);\n\n  // Updates the \"modal\" component if props are changed\n  // Use carefully since it might result in unnecessary rerenders\n  // Typically if modal is staic there is no need for updates, use when you expect props to change\n  useEffect(() => {\n    // NodeId is needed in case there are 2 useModal hooks on the same page and one has updateOnPropsChange\n    if (updateOnPropsChange && isOpen && nodeId === modalId) {\n      const modalProps = get(modal, \"props\");\n      const oldModalProps = get(modalNode, \"props\");\n      // Note: I tried to use lodash isEqual to compare props but it is giving false-negatives too easily\n      // For example ConfirmSwapModal in exchange has ~500 lines prop object that stringifies to same string\n      // and online diff checker says both objects are identical but lodash isEqual thinks they are different\n      // Do not try to replace JSON.stringify with isEqual, high risk of infinite rerenders\n      // TODO: Find a good way to handle modal updates, this whole flow is just backwards-compatible workaround,\n      // would be great to simplify the logic here\n      if (modalProps && oldModalProps && JSON.stringify(modalProps) !== JSON.stringify(oldModalProps)) {\n        setModalNode(modal);\n      }\n    }\n  }, [updateOnPropsChange, nodeId, modalId, isOpen, modal, modalNode, setModalNode]);\n\n  useEffect(() => {\n    setCloseOnOverlayClick(closeOnOverlayClick);\n  }, [closeOnOverlayClick, setCloseOnOverlayClick]);\n\n  return [onPresentCallback, onDismiss];\n};\n\nexport default useModal;\n"],"mappings":"AAAA,OAAgBA,WAAW,CAAEC,UAAU,CAAEC,SAAS,KAAQ,OAAO,CACjE,MAAO,CAAAC,GAAG,KAAM,YAAY,CAC5B,OAASC,OAAO,KAAQ,gBAAgB,CAGxC,KAAM,CAAAC,QAAQ,CAAG,QAAAA,CACfC,KAAsB,CAIC,IAHvB,CAAAC,mBAAmB,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,IAAI,IAC1B,CAAAG,mBAAmB,CAAAH,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,KAAK,IAC3B,CAAAI,OAAO,CAAAJ,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,eAAe,CAEzB,KAAM,CAAEK,MAAM,CAAEC,MAAM,CAAEC,SAAS,CAAEC,YAAY,CAAEC,SAAS,CAAEC,SAAS,CAAEC,sBAAuB,CAAC,CAAGlB,UAAU,CAACG,OAAO,CAAC,CACrH,KAAM,CAAAgB,iBAAiB,CAAGpB,WAAW,CAAC,IAAM,CAC1CiB,SAAS,CAACX,KAAK,CAAEM,OAAO,CAAC,CAC3B,CAAC,CAAE,CAACN,KAAK,CAAEM,OAAO,CAAEK,SAAS,CAAC,CAAC,CAE/B;AACA;AACA;AACAf,SAAS,CAAC,IAAM,CACd;AACA,GAAIS,mBAAmB,EAAIE,MAAM,EAAIC,MAAM,GAAKF,OAAO,CAAE,CACvD,KAAM,CAAAS,UAAU,CAAGlB,GAAG,CAACG,KAAK,CAAE,OAAO,CAAC,CACtC,KAAM,CAAAgB,aAAa,CAAGnB,GAAG,CAACY,SAAS,CAAE,OAAO,CAAC,CAC7C;AACA;AACA;AACA;AACA;AACA;AACA,GAAIM,UAAU,EAAIC,aAAa,EAAIC,IAAI,CAACC,SAAS,CAACH,UAAU,CAAC,GAAKE,IAAI,CAACC,SAAS,CAACF,aAAa,CAAC,CAAE,CAC/FN,YAAY,CAACV,KAAK,CAAC,CACrB,CACF,CACF,CAAC,CAAE,CAACK,mBAAmB,CAAEG,MAAM,CAAEF,OAAO,CAAEC,MAAM,CAAEP,KAAK,CAAES,SAAS,CAAEC,YAAY,CAAC,CAAC,CAElFd,SAAS,CAAC,IAAM,CACdiB,sBAAsB,CAACZ,mBAAmB,CAAC,CAC7C,CAAC,CAAE,CAACA,mBAAmB,CAAEY,sBAAsB,CAAC,CAAC,CAEjD,MAAO,CAACC,iBAAiB,CAAEF,SAAS,CAAC,CACvC,CAAC,CAED,cAAe,CAAAb,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module"}