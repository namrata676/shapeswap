{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers';\nconst applyNodeDataToLotteriesGraphResponse = (nodeData, graphResponse) => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map(nodeRound => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: ''\n      };\n    });\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more reliable\n  const mergedResponse = graphResponse.map((graphRound, index) => {\n    const nodeRound = nodeData[index];\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          finalNumber: nodeRound.finalNumber.toString(),\n          startTime: nodeRound.startTime,\n          status: nodeRound.status,\n          id: graphRound.id,\n          ticketPrice: graphRound.ticketPrice,\n          totalTickets: graphRound.totalTickets,\n          totalUsers: graphRound.totalUsers,\n          winningTickets: graphRound.winningTickets\n        };\n      }\n      return graphRound;\n    }\n    return graphRound;\n  });\n  return mergedResponse;\n};\nconst getGraphLotteries = async () => {\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getLotteries {\n          lotteries(first: 100, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `);\n    return response.lotteries;\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\nconst getLotteriesData = async currentLotteryId => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId);\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall);\n  const graphResponse = await getGraphLotteries();\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse);\n  return mergedData;\n};\nexport default getLotteriesData;","map":{"version":3,"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","applyNodeDataToLotteriesGraphResponse","nodeData","graphResponse","length","map","nodeRound","endTime","finalNumber","toString","startTime","status","id","lotteryId","ticketPrice","priceTicketInCake","totalTickets","totalUsers","winningTickets","mergedResponse","graphRound","index","isLoading","getGraphLotteries","response","lotteries","error","console","getLotteriesData","currentLotteryId","idsForNodesCall","mergedData"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/state/lottery/getLotteriesData.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryRoundGraphEntity, LotteryResponse } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers'\n\nconst applyNodeDataToLotteriesGraphResponse = (\n  nodeData: LotteryResponse[],\n  graphResponse: LotteryRoundGraphEntity[],\n): LotteryRoundGraphEntity[] => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map((nodeRound) => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: '',\n      }\n    })\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more reliable\n  const mergedResponse = graphResponse.map((graphRound, index) => {\n    const nodeRound = nodeData[index]\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          finalNumber: nodeRound.finalNumber.toString(),\n          startTime: nodeRound.startTime,\n          status: nodeRound.status,\n          id: graphRound.id,\n          ticketPrice: graphRound.ticketPrice,\n          totalTickets: graphRound.totalTickets,\n          totalUsers: graphRound.totalUsers,\n          winningTickets: graphRound.winningTickets,\n        }\n      }\n      return graphRound\n    }\n    return graphRound\n  })\n  return mergedResponse\n}\n\nconst getGraphLotteries = async (): Promise<LotteryRoundGraphEntity[]> => {\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getLotteries {\n          lotteries(first: 100, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `,\n    )\n    return response.lotteries\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst getLotteriesData = async (currentLotteryId: string): Promise<LotteryRoundGraphEntity[]> => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId)\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall)\n  const graphResponse = await getGraphLotteries()\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse)\n  return mergedData\n}\n\nexport default getLotteriesData\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,GAAG,QAAQ,iBAAiB;AAC9C,SAASC,iBAAiB,QAAQ,4BAA4B;AAE9D,SAASC,gBAAgB,EAAEC,sBAAsB,QAAQ,WAAW;AAEpE,MAAMC,qCAAqC,GAAGA,CAC5CC,QAA2B,EAC3BC,aAAwC,KACV;EAC9B;EACA,IAAIA,aAAa,CAACC,MAAM,KAAK,CAAC,EAAE;IAC9B,OAAOF,QAAQ,CAACG,GAAG,CAAEC,SAAS,IAAK;MACjC,OAAO;QACLC,OAAO,EAAED,SAAS,CAACC,OAAO;QAC1BC,WAAW,EAAEF,SAAS,CAACE,WAAW,CAACC,QAAQ,CAAC,CAAC;QAC7CC,SAAS,EAAEJ,SAAS,CAACI,SAAS;QAC9BC,MAAM,EAAEL,SAAS,CAACK,MAAM;QACxBC,EAAE,EAAEN,SAAS,CAACO,SAAS,CAACJ,QAAQ,CAAC,CAAC;QAClCK,WAAW,EAAER,SAAS,CAACS,iBAAiB;QACxCC,YAAY,EAAE,EAAE;QAChBC,UAAU,EAAE,EAAE;QACdC,cAAc,EAAE;MAClB,CAAC;IACH,CAAC,CAAC;EACJ;;EAEA;EACA,MAAMC,cAAc,GAAGhB,aAAa,CAACE,GAAG,CAAC,CAACe,UAAU,EAAEC,KAAK,KAAK;IAC9D,MAAMf,SAAS,GAAGJ,QAAQ,CAACmB,KAAK,CAAC;IACjC;IACA,IAAIf,SAAS,EAAE;MACb;MACA,IAAI,CAACA,SAAS,CAACgB,SAAS,EAAE;QACxB,OAAO;UACLf,OAAO,EAAED,SAAS,CAACC,OAAO;UAC1BC,WAAW,EAAEF,SAAS,CAACE,WAAW,CAACC,QAAQ,CAAC,CAAC;UAC7CC,SAAS,EAAEJ,SAAS,CAACI,SAAS;UAC9BC,MAAM,EAAEL,SAAS,CAACK,MAAM;UACxBC,EAAE,EAAEQ,UAAU,CAACR,EAAE;UACjBE,WAAW,EAAEM,UAAU,CAACN,WAAW;UACnCE,YAAY,EAAEI,UAAU,CAACJ,YAAY;UACrCC,UAAU,EAAEG,UAAU,CAACH,UAAU;UACjCC,cAAc,EAAEE,UAAU,CAACF;QAC7B,CAAC;MACH;MACA,OAAOE,UAAU;IACnB;IACA,OAAOA,UAAU;EACnB,CAAC,CAAC;EACF,OAAOD,cAAc;AACvB,CAAC;AAED,MAAMI,iBAAiB,GAAG,MAAAA,CAAA,KAAgD;EACxE,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAM5B,OAAO,CAC5BE,iBAAiB,EACjBD,GAAG;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OACI,CAAC;IACD,OAAO2B,QAAQ,CAACC,SAAS;EAC3B,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC;IACpB,OAAO,EAAE;EACX;AACF,CAAC;AAED,MAAME,gBAAgB,GAAG,MAAOC,gBAAwB,IAAyC;EAC/F,MAAMC,eAAe,GAAG/B,gBAAgB,CAAC8B,gBAAgB,CAAC;EAC1D,MAAM3B,QAAQ,GAAG,MAAMF,sBAAsB,CAAC8B,eAAe,CAAC;EAC9D,MAAM3B,aAAa,GAAG,MAAMoB,iBAAiB,CAAC,CAAC;EAC/C,MAAMQ,UAAU,GAAG9B,qCAAqC,CAACC,QAAQ,EAAEC,aAAa,CAAC;EACjF,OAAO4B,UAAU;AACnB,CAAC;AAED,eAAeH,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module"}