{"ast":null,"code":"'use strict';\n\nconst mh = require('multihashes');\nconst multibase = require('multibase');\nconst multicodec = require('multicodec');\nconst CIDUtil = require('./cid-util');\nconst {\n  concat: uint8ArrayConcat\n} = require('uint8arrays/concat');\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\nconst {\n  equals: uint8ArrayEquals\n} = require('uint8arrays/equals');\nconst codecs = multicodec.nameToCode;\nconst codecInts = /** @type {CodecName[]} */Object.keys(codecs).reduce((p, name) => {\n  p[codecs[name]] = name;\n  return p;\n}, /** @type {Record<CodecCode, CodecName>} */{});\nconst symbol = Symbol.for('@ipld/js-cid/CID');\n\n/**\n * @typedef {Object} SerializedCID\n * @property {string} codec\n * @property {number} version\n * @property {Uint8Array} hash\n */\n/**\n * @typedef {0|1} CIDVersion\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n * @typedef {import('multicodec').CodecName} CodecName\n * @typedef {import('multicodec').CodecCode} CodecCode\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n *\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {CIDVersion | string | Uint8Array | CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor(version, codec, multihash, multibaseName) {\n    // We have below three blank field accessors only because\n    // otherwise TS will not pick them up if done after assignemnts\n\n    /**\n     * The version of the CID.\n     *\n     * @type {CIDVersion}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.version;\n\n    /**\n     * The codec of the CID.\n     *\n     * @deprecated\n     * @type {CodecName}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.codec;\n\n    /**\n     * The multihash of the CID.\n     *\n     * @type {Uint8Array}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.multihash;\n    Object.defineProperty(this, symbol, {\n      value: true\n    });\n    if (CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = /** @type {CID} */version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = cid.multihash;\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      // @ts-ignore\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version);\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version);\n        this.version = /** @type {CIDVersion} */parseInt(cid[0].toString(), 16);\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n    if (version instanceof Uint8Array) {\n      const v = parseInt(version[0].toString(), 16);\n      if (v === 1) {\n        // version is a CID Uint8Array\n        const cid = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(cid.slice(1));\n        this.multihash = multicodec.rmPrefix(cid.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n      CID.validateCID(this);\n      return;\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    this.version = version;\n    if (typeof codec === 'number') {\n      // @ts-ignore\n      codec = codecInts[codec];\n    }\n    this.codec = /** @type {CodecName} */codec;\n    this.multihash = /** @type {Uint8Array} */multihash;\n\n    /**\n     * Multibase name as string.\n     *\n     * @deprecated\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n\n  /**\n   * The CID as a `Uint8Array`\n   *\n   * @returns {Uint8Array}\n   *\n   */\n  get bytes() {\n    // @ts-ignore\n    let bytes = this._bytes;\n    if (!bytes) {\n      if (this.version === 0) {\n        bytes = this.multihash;\n      } else if (this.version === 1) {\n        const codec = multicodec.getCodeVarint(this.codec);\n        bytes = uint8ArrayConcat([[1], codec, this.multihash], 1 + codec.byteLength + this.multihash.byteLength);\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      // Cache this Uint8Array so it doesn't have to be recreated\n      Object.defineProperty(this, '_bytes', {\n        value: bytes\n      });\n    }\n    return bytes;\n  }\n\n  /**\n   * The prefix of the CID.\n   *\n   * @returns {Uint8Array}\n   */\n  get prefix() {\n    const codec = multicodec.getCodeVarint(this.codec);\n    const multihash = mh.prefix(this.multihash);\n    const prefix = uint8ArrayConcat([[this.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n    return prefix;\n  }\n\n  /**\n   * The codec of the CID in its number form.\n   *\n   * @returns {CodecCode}\n   */\n  get code() {\n    return codecs[this.codec];\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0() {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n    }\n    const {\n      name,\n      length\n    } = mh.decode(this.multihash);\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n    }\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n    }\n    return new CID(0, this.codec, this.multihash);\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1() {\n    return new CID(1, this.codec, this.multihash, this.multibaseName);\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString() {\n    let base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n    // @ts-ignore non enumerable cache property\n    if (this.string && this.string.length !== 0 && base === this.multibaseName) {\n      // @ts-ignore non enumerable cache property\n      return this.string;\n    }\n    let str;\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n      }\n      str = mh.toB58String(this.multihash);\n    } else if (this.version === 1) {\n      str = uint8ArrayToString(multibase.encode(base, this.bytes));\n    } else {\n      throw new Error('unsupported version');\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', {\n        value: str\n      });\n    }\n    return str;\n  }\n\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {string}\n   */\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return 'CID(' + this.toString() + ')';\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toString(base) {\n    return this.toBaseEncodedString(base);\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON() {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    };\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {boolean}\n   */\n  equals(other) {\n    return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other - The other CID.\n   * @returns {void}\n   */\n  static validateCID(other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other);\n    if (errorMsg) {\n      throw new Error(errorMsg);\n    }\n  }\n\n  /**\n   * Check if object is a CID instance\n   *\n   * @param {any} value\n   * @returns {value is CID}\n   */\n  static isCID(value) {\n    return value instanceof CID || Boolean(value && value[symbol]);\n  }\n}\nCID.codecs = codecs;\nmodule.exports = CID;","map":{"version":3,"names":["mh","require","multibase","multicodec","CIDUtil","concat","uint8ArrayConcat","toString","uint8ArrayToString","equals","uint8ArrayEquals","codecs","nameToCode","codecInts","Object","keys","reduce","p","name","symbol","Symbol","for","CID","constructor","version","codec","multihash","multibaseName","defineProperty","value","isCID","cid","baseName","isEncoded","decode","parseInt","getCodec","slice","rmPrefix","fromB58String","validateCID","Uint8Array","v","bytes","_bytes","getCodeVarint","byteLength","Error","prefix","code","toV0","length","toV1","toBaseEncodedString","base","arguments","undefined","string","str","toB58String","encode","toJSON","hash","other","errorMsg","checkCIDComponents","Boolean","module","exports"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/node_modules/cids/src/index.js"],"sourcesContent":["'use strict'\n\nconst mh = require('multihashes')\nconst multibase = require('multibase')\nconst multicodec = require('multicodec')\nconst CIDUtil = require('./cid-util')\nconst { concat: uint8ArrayConcat } = require('uint8arrays/concat')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { equals: uint8ArrayEquals } = require('uint8arrays/equals')\n\nconst codecs = multicodec.nameToCode\nconst codecInts = /** @type {CodecName[]} */(Object.keys(codecs)).reduce((p, name) => {\n  p[codecs[name]] = name\n  return p\n}, /** @type {Record<CodecCode, CodecName>} */({}))\n\nconst symbol = Symbol.for('@ipld/js-cid/CID')\n\n/**\n * @typedef {Object} SerializedCID\n * @property {string} codec\n * @property {number} version\n * @property {Uint8Array} hash\n */\n/**\n * @typedef {0|1} CIDVersion\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n * @typedef {import('multicodec').CodecName} CodecName\n * @typedef {import('multicodec').CodecCode} CodecCode\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n *\n * @class CID\n */\nclass CID {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {CIDVersion | string | Uint8Array | CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  constructor (version, codec, multihash, multibaseName) {\n    // We have below three blank field accessors only because\n    // otherwise TS will not pick them up if done after assignemnts\n\n    /**\n     * The version of the CID.\n     *\n     * @type {CIDVersion}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.version\n\n    /**\n     * The codec of the CID.\n     *\n     * @deprecated\n     * @type {CodecName}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.codec\n\n    /**\n     * The multihash of the CID.\n     *\n     * @type {Uint8Array}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.multihash\n\n    Object.defineProperty(this, symbol, { value: true })\n    if (CID.isCID(version)) {\n      // version is an exising CID instance\n      const cid = /** @type {CID} */(version)\n      this.version = cid.version\n      this.codec = cid.codec\n      this.multihash = cid.multihash\n      // Default guard for when a CID < 0.7 is passed with no multibaseName\n      // @ts-ignore\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')\n      return\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      const baseName = multibase.isEncoded(version)\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        const cid = multibase.decode(version)\n        this.version = /** @type {CIDVersion} */(parseInt(cid[0].toString(), 16))\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = baseName\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = mh.fromB58String(version)\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      Object.defineProperty(this, 'string', { value: version })\n      return\n    }\n\n    if (version instanceof Uint8Array) {\n      const v = parseInt(version[0].toString(), 16)\n      if (v === 1) {\n        // version is a CID Uint8Array\n        const cid = version\n        this.version = v\n        this.codec = multicodec.getCodec(cid.slice(1))\n        this.multihash = multicodec.rmPrefix(cid.slice(1))\n        this.multibaseName = 'base32'\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0\n        this.codec = 'dag-pb'\n        this.multihash = version\n        this.multibaseName = 'base58btc'\n      }\n      CID.validateCID(this)\n      return\n    }\n\n    // otherwise, assemble the CID from the parameters\n\n    this.version = version\n\n    if (typeof codec === 'number') {\n      // @ts-ignore\n      codec = codecInts[codec]\n    }\n\n    this.codec = /** @type {CodecName} */ (codec)\n\n    this.multihash = /** @type {Uint8Array} */ (multihash)\n\n    /**\n     * Multibase name as string.\n     *\n     * @deprecated\n     * @type {string}\n     */\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')\n\n    CID.validateCID(this)\n  }\n\n  /**\n   * The CID as a `Uint8Array`\n   *\n   * @returns {Uint8Array}\n   *\n   */\n  get bytes () {\n    // @ts-ignore\n    let bytes = this._bytes\n\n    if (!bytes) {\n      if (this.version === 0) {\n        bytes = this.multihash\n      } else if (this.version === 1) {\n        const codec = multicodec.getCodeVarint(this.codec)\n        bytes = uint8ArrayConcat([\n          [1], codec, this.multihash\n        ], 1 + codec.byteLength + this.multihash.byteLength)\n      } else {\n        throw new Error('unsupported version')\n      }\n\n      // Cache this Uint8Array so it doesn't have to be recreated\n      Object.defineProperty(this, '_bytes', { value: bytes })\n    }\n\n    return bytes\n  }\n\n  /**\n   * The prefix of the CID.\n   *\n   * @returns {Uint8Array}\n   */\n  get prefix () {\n    const codec = multicodec.getCodeVarint(this.codec)\n    const multihash = mh.prefix(this.multihash)\n    const prefix = uint8ArrayConcat([\n      [this.version], codec, multihash\n    ], 1 + codec.byteLength + multihash.byteLength)\n\n    return prefix\n  }\n\n  /**\n   * The codec of the CID in its number form.\n   *\n   * @returns {CodecCode}\n   */\n  get code () {\n    return codecs[this.codec]\n  }\n\n  /**\n   * Convert to a CID of version `0`.\n   *\n   * @returns {CID}\n   */\n  toV0 () {\n    if (this.codec !== 'dag-pb') {\n      throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n    }\n\n    const { name, length } = mh.decode(this.multihash)\n\n    if (name !== 'sha2-256') {\n      throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n    }\n\n    if (length !== 32) {\n      throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')\n    }\n\n    return new CID(0, this.codec, this.multihash)\n  }\n\n  /**\n   * Convert to a CID of version `1`.\n   *\n   * @returns {CID}\n   */\n  toV1 () {\n    return new CID(1, this.codec, this.multihash, this.multibaseName)\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toBaseEncodedString (base = this.multibaseName) {\n    // @ts-ignore non enumerable cache property\n    if (this.string && this.string.length !== 0 && base === this.multibaseName) {\n      // @ts-ignore non enumerable cache property\n      return this.string\n    }\n    let str\n    if (this.version === 0) {\n      if (base !== 'base58btc') {\n        throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')\n      }\n      str = mh.toB58String(this.multihash)\n    } else if (this.version === 1) {\n      str = uint8ArrayToString(multibase.encode(base, this.bytes))\n    } else {\n      throw new Error('unsupported version')\n    }\n    if (base === this.multibaseName) {\n      // cache the string value\n      Object.defineProperty(this, 'string', { value: str })\n    }\n    return str\n  }\n\n  /**\n   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n   *\n   * @returns {string}\n   */\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    return 'CID(' + this.toString() + ')'\n  }\n\n  /**\n   * Encode the CID into a string.\n   *\n   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n   * @returns {string}\n   */\n  toString (base) {\n    return this.toBaseEncodedString(base)\n  }\n\n  /**\n   * Serialize to a plain object.\n   *\n   * @returns {SerializedCID}\n   */\n  toJSON () {\n    return {\n      codec: this.codec,\n      version: this.version,\n      hash: this.multihash\n    }\n  }\n\n  /**\n   * Compare equality with another CID.\n   *\n   * @param {CID} other\n   * @returns {boolean}\n   */\n  equals (other) {\n    return this.codec === other.codec &&\n      this.version === other.version &&\n      uint8ArrayEquals(this.multihash, other.multihash)\n  }\n\n  /**\n   * Test if the given input is a valid CID object.\n   * Throws if it is not.\n   *\n   * @param {any} other - The other CID.\n   * @returns {void}\n   */\n  static validateCID (other) {\n    const errorMsg = CIDUtil.checkCIDComponents(other)\n    if (errorMsg) {\n      throw new Error(errorMsg)\n    }\n  }\n\n  /**\n   * Check if object is a CID instance\n   *\n   * @param {any} value\n   * @returns {value is CID}\n   */\n  static isCID (value) {\n    return value instanceof CID || Boolean(value && value[symbol])\n  }\n}\n\nCID.codecs = codecs\n\nmodule.exports = CID\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}