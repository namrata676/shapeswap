{"ast":null,"code":"import { AbstractConnector } from '@web3-react/abstract-connector';\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nvar URI_AVAILABLE = 'URI_AVAILABLE';\nvar UserRejectedRequestError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(UserRejectedRequestError, _Error);\n  function UserRejectedRequestError() {\n    var _this;\n    _this = _Error.call(this) || this;\n    _this.name = _this.constructor.name;\n    _this.message = 'The user rejected the request.';\n    return _this;\n  }\n  return UserRejectedRequestError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction getSupportedChains(_ref) {\n  var supportedChainIds = _ref.supportedChainIds,\n    rpc = _ref.rpc;\n  if (supportedChainIds) {\n    return supportedChainIds;\n  }\n  return rpc ? Object.keys(rpc).map(function (k) {\n    return Number(k);\n  }) : undefined;\n}\nvar WalletConnectConnector = /*#__PURE__*/function (_AbstractConnector) {\n  _inheritsLoose(WalletConnectConnector, _AbstractConnector);\n  function WalletConnectConnector(config) {\n    var _this2;\n    _this2 = _AbstractConnector.call(this, {\n      supportedChainIds: getSupportedChains(config)\n    }) || this;\n    _this2.config = config;\n    _this2.handleChainChanged = _this2.handleChainChanged.bind(_assertThisInitialized(_this2));\n    _this2.handleAccountsChanged = _this2.handleAccountsChanged.bind(_assertThisInitialized(_this2));\n    _this2.handleDisconnect = _this2.handleDisconnect.bind(_assertThisInitialized(_this2));\n    return _this2;\n  }\n  var _proto = WalletConnectConnector.prototype;\n  _proto.handleChainChanged = function handleChainChanged(chainId) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId);\n    }\n    this.emitUpdate({\n      chainId: chainId\n    });\n  };\n  _proto.handleAccountsChanged = function handleAccountsChanged(accounts) {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts);\n    }\n    this.emitUpdate({\n      account: accounts[0]\n    });\n  };\n  _proto.handleDisconnect = function handleDisconnect() {\n    if (process.env.NODE_ENV !== \"production\") {\n      console.log(\"Handling 'disconnect' event\");\n    } // we have to do this because of a @walletconnect/web3-provider bug\n\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged);\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged);\n      this.walletConnectProvider = undefined;\n    }\n    this.emitDeactivate();\n  };\n  _proto.activate = function activate() {\n    try {\n      var _this4 = this;\n      var _temp5 = function _temp5() {\n        function _temp2() {\n          var account;\n          return Promise.resolve(new Promise(function (resolve, reject) {\n            var userReject = function userReject() {\n              // Erase the provider manually\n              _this4.walletConnectProvider = undefined;\n              reject(new UserRejectedRequestError());\n            }; // Workaround to bubble up the error when user reject the connection\n\n            _this4.walletConnectProvider.connector.on('disconnect', function () {\n              // Check provider has not been enabled to prevent this event callback from being called in the future\n              if (!account) {\n                userReject();\n              }\n            });\n            _this4.walletConnectProvider.enable().then(function (accounts) {\n              return resolve(accounts[0]);\n            })[\"catch\"](function (error) {\n              // TODO ideally this would be a better check\n              if (error.message === 'User closed modal') {\n                userReject();\n                return;\n              }\n              reject(error);\n            });\n          })[\"catch\"](function (err) {\n            throw err;\n          })).then(function (_Promise$catch) {\n            account = _Promise$catch;\n            _this4.walletConnectProvider.on('disconnect', _this4.handleDisconnect);\n            _this4.walletConnectProvider.on('chainChanged', _this4.handleChainChanged);\n            _this4.walletConnectProvider.on('accountsChanged', _this4.handleAccountsChanged);\n            return {\n              provider: _this4.walletConnectProvider,\n              account: account\n            };\n          });\n        }\n        var _temp = function () {\n          if (!_this4.walletConnectProvider.connector.connected) {\n            return Promise.resolve(_this4.walletConnectProvider.connector.createSession(_this4.config.chainId ? {\n              chainId: _this4.config.chainId\n            } : undefined)).then(function () {\n              _this4.emit(URI_AVAILABLE, _this4.walletConnectProvider.connector.uri);\n            });\n          }\n        }();\n\n        // ensure that the uri is going to be available, and emit an event if there's a new uri\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      };\n      var _temp6 = function () {\n        if (!_this4.walletConnectProvider) {\n          return Promise.resolve(import('@walletconnect/ethereum-provider').then(function (m) {\n            var _m$default;\n            return (_m$default = m == null ? void 0 : m[\"default\"]) != null ? _m$default : m;\n          })).then(function (WalletConnectProvider) {\n            _this4.walletConnectProvider = new WalletConnectProvider(_this4.config);\n          });\n        }\n      }();\n      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  _proto.getProvider = function getProvider() {\n    try {\n      var _this6 = this;\n      return Promise.resolve(_this6.walletConnectProvider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  _proto.getChainId = function getChainId() {\n    try {\n      var _this8 = this;\n      return Promise.resolve(_this8.walletConnectProvider.chainId);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  _proto.getAccount = function getAccount() {\n    try {\n      var _this10 = this;\n      return Promise.resolve(_this10.walletConnectProvider.accounts).then(function (accounts) {\n        return accounts[0];\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  _proto.deactivate = function deactivate() {\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.removeListener('disconnect', this.handleDisconnect);\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged);\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged);\n      this.walletConnectProvider.disconnect();\n    }\n  };\n  _proto.close = function close() {\n    try {\n      var _this12 = this;\n      _this12.emitDeactivate();\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  return WalletConnectConnector;\n}(AbstractConnector);\nexport { URI_AVAILABLE, UserRejectedRequestError, WalletConnectConnector };","map":{"version":3,"sources":["../src/index.ts"],"names":["URI_AVAILABLE","UserRejectedRequestError","Error","name","constructor","message","getSupportedChains","supportedChainIds","rpc","keys","map","Number","k","undefined","WalletConnectConnector","AbstractConnector","config","handleChainChanged","bind","handleAccountsChanged","handleDisconnect","chainId","console","log","emitUpdate","accounts","account","walletConnectProvider","removeListener","emitDeactivate","activate","WalletConnectProvider","then","m","connector","connected","createSession","emit","uri","Promise","resolve","reject","userReject","on","enable","error","err","provider","getProvider","getChainId","getAccount","deactivate","disconnect","close"],"mappings":"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","sourcesContent":["import WalletConnectProvider from '@walletconnect/ethereum-provider'\nimport { IWCEthRpcConnectionOptions } from '@walletconnect/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport { ConnectorUpdate } from '@web3-react/types'\n\nexport const URI_AVAILABLE = 'URI_AVAILABLE'\n\nexport interface WalletConnectConnectorArguments extends IWCEthRpcConnectionOptions {\n  supportedChainIds?: number[]\n}\n\nexport class UserRejectedRequestError extends Error {\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    this.message = 'The user rejected the request.'\n  }\n}\n\nfunction getSupportedChains({ supportedChainIds, rpc }: WalletConnectConnectorArguments): number[] | undefined {\n  if (supportedChainIds) {\n    return supportedChainIds\n  }\n\n  return rpc ? Object.keys(rpc).map(k => Number(k)) : undefined\n}\n\nexport class WalletConnectConnector extends AbstractConnector {\n  public walletConnectProvider?: WalletConnectProvider\n  private readonly config: WalletConnectConnectorArguments\n\n  constructor(config: WalletConnectConnectorArguments) {\n    super({ supportedChainIds: getSupportedChains(config) })\n    this.config = config\n\n    this.handleChainChanged = this.handleChainChanged.bind(this)\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this)\n    this.handleDisconnect = this.handleDisconnect.bind(this)\n  }\n\n  private handleChainChanged(chainId: number | string): void {\n    if (__DEV__) {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId)\n    }\n    this.emitUpdate({ chainId })\n  }\n\n  private handleAccountsChanged(accounts: string[]): void {\n    if (__DEV__) {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts)\n    }\n    this.emitUpdate({ account: accounts[0] })\n  }\n\n  private handleDisconnect(): void {\n    if (__DEV__) {\n      console.log(\"Handling 'disconnect' event\")\n    }\n    // we have to do this because of a @walletconnect/web3-provider bug\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n      this.walletConnectProvider = undefined\n    }\n    this.emitDeactivate()\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.walletConnectProvider) {\n      const WalletConnectProvider = await import('@walletconnect/ethereum-provider').then(m => m?.default ?? m)\n      this.walletConnectProvider = new WalletConnectProvider(this.config)\n    }\n\n    // ensure that the uri is going to be available, and emit an event if there's a new uri\n    if (!this.walletConnectProvider.connector.connected) {\n      await this.walletConnectProvider.connector.createSession(\n        this.config.chainId ? { chainId: this.config.chainId } : undefined\n      )\n      this.emit(URI_AVAILABLE, this.walletConnectProvider.connector.uri)\n    }\n\n    let account: string\n    account = await new Promise<string>((resolve, reject) => {\n      const userReject = () => {\n        // Erase the provider manually\n        this.walletConnectProvider = undefined\n        reject(new UserRejectedRequestError())\n      }\n\n      // Workaround to bubble up the error when user reject the connection\n      this.walletConnectProvider!.connector.on('disconnect', () => {\n        // Check provider has not been enabled to prevent this event callback from being called in the future\n        if (!account) {\n          userReject()\n        }\n      })\n\n      this.walletConnectProvider!.enable()\n        .then((accounts: string[]) => resolve(accounts[0]))\n        .catch((error: Error): void => {\n          // TODO ideally this would be a better check\n          if (error.message === 'User closed modal') {\n            userReject()\n            return\n          }\n          reject(error)\n        })\n    }).catch(err => {\n      throw err\n    })\n\n    this.walletConnectProvider.on('disconnect', this.handleDisconnect)\n    this.walletConnectProvider.on('chainChanged', this.handleChainChanged)\n    this.walletConnectProvider.on('accountsChanged', this.handleAccountsChanged)\n\n    return { provider: this.walletConnectProvider, account }\n  }\n\n  public async getProvider(): Promise<any> {\n    return this.walletConnectProvider\n  }\n\n  public async getChainId(): Promise<number | string> {\n    return Promise.resolve(this.walletConnectProvider!.chainId)\n  }\n\n  public async getAccount(): Promise<null | string> {\n    return Promise.resolve(this.walletConnectProvider!.accounts).then((accounts: string[]): string => accounts[0])\n  }\n\n  public deactivate() {\n    if (this.walletConnectProvider) {\n      this.walletConnectProvider.removeListener('disconnect', this.handleDisconnect)\n      this.walletConnectProvider.removeListener('chainChanged', this.handleChainChanged)\n      this.walletConnectProvider.removeListener('accountsChanged', this.handleAccountsChanged)\n      this.walletConnectProvider.disconnect()\n    }\n  }\n\n  public async close() {\n    this.emitDeactivate()\n  }\n}\n"]},"metadata":{},"sourceType":"module"}