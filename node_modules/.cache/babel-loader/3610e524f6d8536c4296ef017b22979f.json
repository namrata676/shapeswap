{"ast":null,"code":"/* eslint-disable no-continue *//* eslint-disable lines-between-class-members *//* eslint-disable consistent-return *//* eslint-disable no-lonely-if *//* eslint-disable no-else-return */// import invariant from 'tiny-invariant'\nimport{ONE,TradeType,ZERO}from'../constants';import{sortedInsert}from'../utils';import{ETHER}from'./currency';import{CurrencyAmount}from'./fractions/currencyAmount';import{Fraction}from'./fractions/fraction';import{Percent}from'./fractions/percent';import{Price}from'./fractions/price';import{TokenAmount}from'./fractions/tokenAmount';import{Route}from'./route';import{Token,WETH}from'./token';/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */function computePriceImpact(midPrice,inputAmount,outputAmount){const exactQuote=midPrice.raw.multiply(inputAmount.raw);// calculate slippage := (exactQuote - outputAmount) / exactQuote\nconst slippage=exactQuote.subtract(outputAmount.raw).divide(exactQuote);return new Percent(slippage.numerator,slippage.denominator);}// minimal interface so the input output comparator may be shared across types\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a,b){// must have same input and output token for comparison\n// invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n// invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\nif(a.outputAmount.equalTo(b.outputAmount)){if(a.inputAmount.equalTo(b.inputAmount)){return 0;}// trade A requires less input than trade B, so A should come first\nif(a.inputAmount.lessThan(b.inputAmount)){return-1;}else{return 1;}}else{// tradeA has less output than trade B, so should come second\nif(a.outputAmount.lessThan(b.outputAmount)){return 1;}else{return-1;}}}// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a,b){const ioComp=inputOutputComparator(a,b);if(ioComp!==0){return ioComp;}// consider lowest slippage next, since these are less likely to fail\nif(a.priceImpact.lessThan(b.priceImpact)){return-1;}else if(a.priceImpact.greaterThan(b.priceImpact)){return 1;}// finally consider the number of hops since each hop costs gas\nreturn a.route.path.length-b.route.path.length;}/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */function wrappedAmount(currencyAmount,chainId){if(currencyAmount instanceof TokenAmount)return currencyAmount;if(currencyAmount.currency===ETHER)return new TokenAmount(WETH[chainId],currencyAmount.raw);// invariant(false, 'CURRENCY')\n}function wrappedCurrency(currency,chainId){if(currency instanceof Token)return currency;if(currency===ETHER)return WETH[chainId];// invariant(false, 'CURRENCY')\n}/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */export class Trade{/**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */static exactIn(route,amountIn){return new Trade(route,amountIn,TradeType.EXACT_INPUT);}/**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */static exactOut(route,amountOut){return new Trade(route,amountOut,TradeType.EXACT_OUTPUT);}constructor(route,amount,tradeType){/**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */this.route=void 0;/**\n   * The type of the trade, either exact in or exact out.\n   */this.tradeType=void 0;/**\n   * The input amount for the trade assuming no slippage.\n   */this.inputAmount=void 0;/**\n   * The output amount for the trade assuming no slippage.\n   */this.outputAmount=void 0;/**\n   * The price expressed in terms of output amount/input amount.\n   */this.executionPrice=void 0;/**\n   * The mid price after the trade executes assuming no slippage.\n   */this.nextMidPrice=void 0;/**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */this.priceImpact=void 0;const amounts=new Array(route.path.length);const nextPairs=new Array(route.pairs.length);if(tradeType===TradeType.EXACT_INPUT){// invariant(currencyEquals(amount.currency, route.input), 'INPUT')\namounts[0]=wrappedAmount(amount,route.chainId);for(let i=0;i<route.path.length-1;i++){const pair=route.pairs[i];const[outputAmount,nextPair]=pair.getOutputAmount(amounts[i]);amounts[i+1]=outputAmount;nextPairs[i]=nextPair;}}else{// invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\namounts[amounts.length-1]=wrappedAmount(amount,route.chainId);for(let i=route.path.length-1;i>0;i--){const pair=route.pairs[i-1];const[inputAmount,nextPair]=pair.getInputAmount(amounts[i]);amounts[i-1]=inputAmount;nextPairs[i-1]=nextPair;}}this.route=route;this.tradeType=tradeType;this.inputAmount=tradeType===TradeType.EXACT_INPUT?amount:route.input===ETHER?CurrencyAmount.ether(amounts[0].raw):amounts[0];this.outputAmount=tradeType===TradeType.EXACT_OUTPUT?amount:route.output===ETHER?CurrencyAmount.ether(amounts[amounts.length-1].raw):amounts[amounts.length-1];this.executionPrice=new Price(this.inputAmount.currency,this.outputAmount.currency,this.inputAmount.raw,this.outputAmount.raw);this.nextMidPrice=Price.fromRoute(new Route(nextPairs,route.input));this.priceImpact=computePriceImpact(route.midPrice,this.inputAmount,this.outputAmount);}/**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */minimumAmountOut(slippageTolerance){// invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\nif(this.tradeType===TradeType.EXACT_OUTPUT){return this.outputAmount;}else{const slippageAdjustedAmountOut=new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;return this.outputAmount instanceof TokenAmount?new TokenAmount(this.outputAmount.token,slippageAdjustedAmountOut):CurrencyAmount.ether(slippageAdjustedAmountOut);}}/**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */maximumAmountIn(slippageTolerance){// invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\nif(this.tradeType===TradeType.EXACT_INPUT){return this.inputAmount;}else{const slippageAdjustedAmountIn=new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;return this.inputAmount instanceof TokenAmount?new TokenAmount(this.inputAmount.token,slippageAdjustedAmountIn):CurrencyAmount.ether(slippageAdjustedAmountIn);}}/**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */static bestTradeExactIn(pairs,currencyAmountIn,currencyOut){let{maxNumResults=3,maxHops=3}=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let currentPairs=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];let originalAmountIn=arguments.length>5&&arguments[5]!==undefined?arguments[5]:currencyAmountIn;let bestTrades=arguments.length>6&&arguments[6]!==undefined?arguments[6]:[];// invariant(pairs.length > 0, 'PAIRS')\n// invariant(maxHops > 0, 'MAX_HOPS')\n// invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\nconst chainId=currencyAmountIn instanceof TokenAmount?currencyAmountIn.token.chainId:currencyOut instanceof Token?currencyOut.chainId:undefined;// invariant(chainId !== undefined, 'CHAIN_ID')\nconst amountIn=wrappedAmount(currencyAmountIn,chainId);const tokenOut=wrappedCurrency(currencyOut,chainId);for(let i=0;i<pairs.length;i++){const pair=pairs[i];// pair irrelevant\nif(!pair.token0.equals(amountIn.token)&&!pair.token1.equals(amountIn.token))continue;if(pair.reserve0.equalTo(ZERO)||pair.reserve1.equalTo(ZERO))continue;let amountOut;try{[amountOut]=pair.getOutputAmount(amountIn);}catch(error){// input too low\nif(1){continue;}throw error;}// we have arrived at the output token, so this is the final trade of one of the paths\nif(amountOut.token.equals(tokenOut)){sortedInsert(bestTrades,new Trade(new Route([...currentPairs,pair],originalAmountIn.currency,currencyOut),originalAmountIn,TradeType.EXACT_INPUT),maxNumResults,tradeComparator);}else if(maxHops>1&&pairs.length>1){const pairsExcludingThisPair=pairs.slice(0,i).concat(pairs.slice(i+1,pairs.length));// otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\nTrade.bestTradeExactIn(pairsExcludingThisPair,amountOut,currencyOut,{maxNumResults,maxHops:maxHops-1},[...currentPairs,pair],originalAmountIn,bestTrades);}}return bestTrades;}/**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */static bestTradeExactOut(pairs,currencyIn,currencyAmountOut){let{maxNumResults=3,maxHops=3}=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};let currentPairs=arguments.length>4&&arguments[4]!==undefined?arguments[4]:[];let originalAmountOut=arguments.length>5&&arguments[5]!==undefined?arguments[5]:currencyAmountOut;let bestTrades=arguments.length>6&&arguments[6]!==undefined?arguments[6]:[];// invariant(pairs.length > 0, 'PAIRS')\n// invariant(maxHops > 0, 'MAX_HOPS')\n// invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\nconst chainId=currencyAmountOut instanceof TokenAmount?currencyAmountOut.token.chainId:currencyIn instanceof Token?currencyIn.chainId:undefined;// invariant(chainId !== undefined, 'CHAIN_ID')\nconst amountOut=wrappedAmount(currencyAmountOut,chainId);const tokenIn=wrappedCurrency(currencyIn,chainId);for(let i=0;i<pairs.length;i++){const pair=pairs[i];// pair irrelevant\nif(!pair.token0.equals(amountOut.token)&&!pair.token1.equals(amountOut.token))continue;if(pair.reserve0.equalTo(ZERO)||pair.reserve1.equalTo(ZERO))continue;let amountIn;try{[amountIn]=pair.getInputAmount(amountOut);}catch(error){// not enough liquidity in this pair\nif(1){continue;}throw error;}// we have arrived at the input token, so this is the first trade of one of the paths\nif(amountIn.token.equals(tokenIn)){sortedInsert(bestTrades,new Trade(new Route([pair,...currentPairs],currencyIn,originalAmountOut.currency),originalAmountOut,TradeType.EXACT_OUTPUT),maxNumResults,tradeComparator);}else if(maxHops>1&&pairs.length>1){const pairsExcludingThisPair=pairs.slice(0,i).concat(pairs.slice(i+1,pairs.length));// otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\nTrade.bestTradeExactOut(pairsExcludingThisPair,currencyIn,amountIn,{maxNumResults,maxHops:maxHops-1},[pair,...currentPairs],originalAmountOut,bestTrades);}}return bestTrades;}}","map":{"version":3,"names":["ONE","TradeType","ZERO","sortedInsert","ETHER","CurrencyAmount","Fraction","Percent","Price","TokenAmount","Route","Token","WETH","computePriceImpact","midPrice","inputAmount","outputAmount","exactQuote","raw","multiply","slippage","subtract","divide","numerator","denominator","inputOutputComparator","a","b","equalTo","lessThan","tradeComparator","ioComp","priceImpact","greaterThan","route","path","length","wrappedAmount","currencyAmount","chainId","currency","wrappedCurrency","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","constructor","amount","tradeType","executionPrice","nextMidPrice","amounts","Array","nextPairs","pairs","i","pair","nextPair","getOutputAmount","getInputAmount","input","ether","output","fromRoute","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","add","invert","quotient","token","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","arguments","undefined","currentPairs","originalAmountIn","bestTrades","tokenOut","token0","equals","token1","reserve0","reserve1","error","pairsExcludingThisPair","slice","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/entities/trade.ts"],"sourcesContent":["/* eslint-disable no-continue */\n/* eslint-disable lines-between-class-members */\n/* eslint-disable consistent-return */\n/* eslint-disable no-lonely-if */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, ETHER } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WETH } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  // invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  // invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw)\n  // invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === ETHER) return WETH[chainId]\n  // invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      // invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      // invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === ETHER\n        ? CurrencyAmount.ether(amounts[0].raw)\n        : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === ETHER\n        ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\n        : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.ether(slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.ether(slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n        ? currencyOut.chainId\n        : undefined\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        [amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (1) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n        ? currencyIn.chainId\n        : undefined\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        [amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (1) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}