{"ast":null,"code":"/* eslint-disable default-case */\n/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable no-useless-constructor */\n// import invariant from 'tiny-invariant'\nimport { TradeType } from './constants';\nimport { validateAndParseAddress } from './utils';\nimport { ETHER } from './entities';\n\n/**\n * Options for producing the arguments to send call to the router.\n */\n\nfunction toHex(currencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`;\n}\nconst ZERO_HEX = '0x0';\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport class Router {\n  /**\n   * Cannot be constructed.\n   */\n  constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  // eslint-disable-next-line lines-between-class-members\n  static swapCallParameters(trade, options) {\n    const etherIn = trade.inputAmount.currency === ETHER;\n    const etherOut = trade.outputAmount.currency === ETHER;\n    // the router does not support both ether in and out\n    // invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    // invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to = validateAndParseAddress(options.recipient);\n    const amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));\n    const amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));\n    const path = trade.route.path.map(token => token.address);\n    const deadline = 'ttl' in options ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}` : `0x${options.deadline.toString(16)}`;\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer);\n    let methodName;\n    let args;\n    let value;\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens';\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH';\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens' : 'swapExactTokensForTokens';\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n      case TradeType.EXACT_OUTPUT:\n        // invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens';\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline];\n          value = amountIn;\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH';\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        } else {\n          methodName = 'swapTokensForExactTokens';\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline];\n          value = ZERO_HEX;\n        }\n        break;\n    }\n    return {\n      methodName,\n      args,\n      value\n    };\n  }\n}","map":{"version":3,"names":["TradeType","validateAndParseAddress","ETHER","toHex","currencyAmount","raw","toString","ZERO_HEX","Router","constructor","swapCallParameters","trade","options","etherIn","inputAmount","currency","etherOut","outputAmount","to","recipient","amountIn","maximumAmountIn","allowedSlippage","amountOut","minimumAmountOut","path","route","map","token","address","deadline","Math","floor","Date","getTime","ttl","useFeeOnTransfer","Boolean","feeOnTransfer","methodName","args","value","tradeType","EXACT_INPUT","EXACT_OUTPUT"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/router.ts"],"sourcesContent":["/* eslint-disable default-case */\n/* eslint-disable @typescript-eslint/no-empty-function */\n/* eslint-disable no-useless-constructor */\n// import invariant from 'tiny-invariant'\nimport { TradeType } from './constants'\nimport { validateAndParseAddress } from './utils'\nimport { CurrencyAmount, ETHER, Percent, Trade } from './entities'\n\n/**\n * Options for producing the arguments to send call to the router.\n */\nexport interface TradeOptions {\n  /**\n   * How much the execution price is allowed to move unfavorably from the trade execution price.\n   */\n  allowedSlippage: Percent\n  /**\n   * How long the swap is valid until it expires, in seconds.\n   * This will be used to produce a `deadline` parameter which is computed from when the swap call parameters\n   * are generated.\n   */\n  ttl: number\n  /**\n   * The account that should receive the output of the swap.\n   */\n  recipient: string\n\n  /**\n   * Whether any of the tokens in the path are fee on transfer tokens, which should be handled with special methods\n   */\n  feeOnTransfer?: boolean\n}\n\nexport interface TradeOptionsDeadline extends Omit<TradeOptions, 'ttl'> {\n  /**\n   * When the transaction expires.\n   * This is an atlernate to specifying the ttl, for when you do not want to use local time.\n   */\n  deadline: number\n}\n\n/**\n * The parameters to use in the call to the Pancake Router to execute a trade.\n */\nexport interface SwapParameters {\n  /**\n   * The method to call on the Pancake Router.\n   */\n  methodName: string\n  /**\n   * The arguments to pass to the method, all hex encoded.\n   */\n  args: (string | string[])[]\n  /**\n   * The amount of wei to send in hex.\n   */\n  value: string\n}\n\nfunction toHex(currencyAmount: CurrencyAmount) {\n  return `0x${currencyAmount.raw.toString(16)}`\n}\n\nconst ZERO_HEX = '0x0'\n\n/**\n * Represents the Pancake Router, and has static methods for helping execute trades.\n */\nexport abstract class Router {\n  /**\n   * Cannot be constructed.\n   */\n  private constructor() {}\n  /**\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trade to produce call parameters for\n   * @param options options for the call parameters\n   */\n  // eslint-disable-next-line lines-between-class-members\n  public static swapCallParameters(trade: Trade, options: TradeOptions | TradeOptionsDeadline): SwapParameters {\n    const etherIn = trade.inputAmount.currency === ETHER\n    const etherOut = trade.outputAmount.currency === ETHER\n    // the router does not support both ether in and out\n    // invariant(!(etherIn && etherOut), 'ETHER_IN_OUT')\n    // invariant(!('ttl' in options) || options.ttl > 0, 'TTL')\n\n    const to: string = validateAndParseAddress(options.recipient)\n    const amountIn: string = toHex(trade.maximumAmountIn(options.allowedSlippage))\n    const amountOut: string = toHex(trade.minimumAmountOut(options.allowedSlippage))\n    const path: string[] = trade.route.path.map((token) => token.address)\n    const deadline =\n      'ttl' in options\n        ? `0x${(Math.floor(new Date().getTime() / 1000) + options.ttl).toString(16)}`\n        : `0x${options.deadline.toString(16)}`\n\n    const useFeeOnTransfer = Boolean(options.feeOnTransfer)\n\n    let methodName: string\n    let args: (string | string[])[]\n    let value: string\n    switch (trade.tradeType) {\n      case TradeType.EXACT_INPUT:\n        if (etherIn) {\n          methodName = useFeeOnTransfer ? 'swapExactETHForTokensSupportingFeeOnTransferTokens' : 'swapExactETHForTokens'\n          // (uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = useFeeOnTransfer ? 'swapExactTokensForETHSupportingFeeOnTransferTokens' : 'swapExactTokensForETH'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = useFeeOnTransfer\n            ? 'swapExactTokensForTokensSupportingFeeOnTransferTokens'\n            : 'swapExactTokensForTokens'\n          // (uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n          args = [amountIn, amountOut, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n      case TradeType.EXACT_OUTPUT:\n        // invariant(!useFeeOnTransfer, 'EXACT_OUT_FOT')\n        if (etherIn) {\n          methodName = 'swapETHForExactTokens'\n          // (uint amountOut, address[] calldata path, address to, uint deadline)\n          args = [amountOut, path, to, deadline]\n          value = amountIn\n        } else if (etherOut) {\n          methodName = 'swapTokensForExactETH'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        } else {\n          methodName = 'swapTokensForExactTokens'\n          // (uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n          args = [amountOut, amountIn, path, to, deadline]\n          value = ZERO_HEX\n        }\n        break\n    }\n    return {\n      methodName,\n      args,\n      value,\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}