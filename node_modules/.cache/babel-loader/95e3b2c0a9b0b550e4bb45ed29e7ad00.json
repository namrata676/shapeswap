{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints';\nimport { ethers } from 'ethers';\nimport { BetPosition, PredictionStatus } from 'state/types';\nimport { multicallv2 } from 'utils/multicall';\nimport predictionsAbi from 'config/abi/predictions.json';\nimport { getPredictionsAddress } from 'utils/addressHelpers';\nimport { getRoundBaseFields, getBetBaseFields, getUserBaseFields } from './queries';\nexport let Result;\n(function (Result) {\n  Result[\"WIN\"] = \"win\";\n  Result[\"LOSE\"] = \"lose\";\n  Result[\"CANCELED\"] = \"canceled\";\n  Result[\"LIVE\"] = \"live\";\n})(Result || (Result = {}));\nexport const numberOrNull = value => {\n  if (value === null) {\n    return null;\n  }\n  const valueNum = Number(value);\n  return Number.isNaN(valueNum) ? null : valueNum;\n};\nexport const transformBetResponse = betResponse => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedHash: betResponse.claimedHash,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB)\n    }\n  };\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round);\n  }\n  return bet;\n};\nexport const transformRoundResponse = roundResponse => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = []\n  } = roundResponse;\n  const getRoundPosition = positionResponse => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL;\n    }\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR;\n    }\n    return null;\n  };\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse)\n  };\n};\nexport const transformTotalWonResponse = (marketResponse, roundResponse) => {\n  const houseRounds = roundResponse.reduce((accum, round) => {\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0);\n  }, 0);\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0;\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0;\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0);\n};\nexport const getRoundResult = (bet, currentEpoch) => {\n  const {\n    round\n  } = bet;\n  if (round.failed) {\n    return Result.CANCELED;\n  }\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE;\n  }\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR;\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE;\n};\n\n/**\n * Given a bet object, check if it is eligible to be claimed or refunded\n */\nexport const getCanClaim = bet => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true);\n};\n\n/**\n * Returns only bets where the user has won.\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\n */\nexport const getUnclaimedWinningBets = bets => {\n  return bets.filter(getCanClaim);\n};\nexport const getTotalWon = async () => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getTotalWonData($position: String) {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n        rounds(where: { position: $position }) {\n          totalAmount\n        }\n      }\n    `, {\n    position: BetPosition.HOUSE\n  });\n  return transformTotalWonResponse(response.market, response.rounds);\n};\nexport const getBetHistory = async function () {\n  let where = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let first = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;\n  let skip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `, {\n    first,\n    skip,\n    where\n  });\n  return response.bets;\n};\nexport const getBet = async betId => {\n  const response = await request(GRAPH_API_PREDICTION, gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `, {\n    id: betId.toLowerCase()\n  });\n  return response.bet;\n};\n\n// V2 REFACTOR\nexport const getLedgerData = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const ledgerCalls = epochs.map(epoch => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account]\n  }));\n  const response = await multicallv2(predictionsAbi, ledgerCalls);\n  return response;\n};\nexport const getClaimStatuses = async (account, epochs) => {\n  const address = getPredictionsAddress();\n  const claimableCalls = epochs.map(epoch => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account]\n  }));\n  const claimableResponses = await multicallv2(predictionsAbi, claimableCalls);\n\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\n  // This can be removed in Predictions V2\n  const ledgerResponses = await getLedgerData(account, epochs);\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const {\n      amount,\n      claimed\n    } = ledgerResponses[index];\n    const epoch = epochs[index];\n    const [claimable] = claimableResponse;\n    return {\n      ...accum,\n      [epoch]: claimable && amount.gt(0) && !claimed\n    };\n  }, {});\n};\nexport const getPredictionData = async () => {\n  const address = getPredictionsAddress();\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(method => ({\n    address,\n    name: method\n  }));\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(predictionsAbi, staticCalls);\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalBlocks: intervalBlocks.toNumber(),\n    bufferBlocks: bufferBlocks.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    rewardRate: rewardRate.toNumber()\n  };\n};\nexport const getRoundsData = async epochs => {\n  const address = getPredictionsAddress();\n  const calls = epochs.map(epoch => ({\n    address,\n    name: 'rounds',\n    params: [epoch]\n  }));\n  const response = await multicallv2(predictionsAbi, calls);\n  return response;\n};\nexport const makeFutureRoundResponse = (epoch, startBlock) => {\n  return {\n    epoch,\n    startBlock,\n    lockBlock: null,\n    endBlock: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false\n  };\n};\nexport const makeRoundData = rounds => {\n  return rounds.reduce((accum, round) => {\n    return {\n      ...accum,\n      [round.epoch.toString()]: round\n    };\n  }, {});\n};\nexport const serializePredictionsLedgerResponse = ledgerResponse => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed\n});\nexport const makeLedgerData = (account, ledgers, epochs) => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum;\n    }\n\n    // If the amount is zero that means the user did not bet\n    if (ledgerResponse.amount.eq(0)) {\n      return accum;\n    }\n    const epoch = epochs[index].toString();\n    return {\n      ...accum,\n      [account]: {\n        ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse)\n      }\n    };\n  }, {});\n};\n\n/**\n * Serializes the return from the \"rounds\" call for redux\n */\nexport const serializePredictionsRoundsResponse = response => {\n  const {\n    epoch,\n    startBlock,\n    lockBlock,\n    endBlock,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardAmount,\n    rewardBaseCalAmount,\n    oracleCalled\n  } = response;\n  return {\n    epoch: epoch.toNumber(),\n    startBlock: startBlock.toNumber(),\n    lockBlock: lockBlock.toNumber(),\n    endBlock: endBlock.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    oracleCalled\n  };\n};\n\n/**\n * Parse serialized values back into ethers.BigNumber\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\n */\nexport const parseBigNumberObj = data => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key];\n    if (value && (value === null || value === void 0 ? void 0 : value.type) === 'BigNumber') {\n      return {\n        ...accum,\n        [key]: ethers.BigNumber.from(value)\n      };\n    }\n    return {\n      ...accum,\n      [key]: value\n    };\n  }, {});\n};","map":{"version":3,"names":["request","gql","GRAPH_API_PREDICTION","ethers","BetPosition","PredictionStatus","multicallv2","predictionsAbi","getPredictionsAddress","getRoundBaseFields","getBetBaseFields","getUserBaseFields","Result","numberOrNull","value","valueNum","Number","isNaN","transformBetResponse","betResponse","bet","id","hash","amount","parseFloat","position","BULL","BEAR","claimed","claimedHash","user","address","block","totalBets","totalBNB","round","transformRoundResponse","roundResponse","epoch","failed","startBlock","startAt","lockAt","lockBlock","lockPrice","endBlock","closePrice","totalAmount","bullBets","bearBets","bearAmount","bullAmount","bets","getRoundPosition","positionResponse","map","transformTotalWonResponse","marketResponse","houseRounds","reduce","accum","totalBNBTreasury","Math","max","getRoundResult","currentEpoch","CANCELED","LIVE","roundResultPosition","WIN","LOSE","getCanClaim","getUnclaimedWinningBets","filter","getTotalWon","response","HOUSE","market","rounds","getBetHistory","where","first","skip","getBet","betId","toLowerCase","getLedgerData","account","epochs","ledgerCalls","name","params","getClaimStatuses","claimableCalls","claimableResponses","ledgerResponses","claimableResponse","index","claimable","gt","getPredictionData","staticCalls","method","intervalBlocks","minBetAmount","paused","bufferBlocks","rewardRate","status","PAUSED","toNumber","toString","getRoundsData","calls","makeFutureRoundResponse","BigNumber","from","toJSON","rewardBaseCalAmount","rewardAmount","oracleCalled","makeRoundData","serializePredictionsLedgerResponse","ledgerResponse","makeLedgerData","ledgers","eq","serializePredictionsRoundsResponse","parseBigNumberObj","data","Object","keys","key","type"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/state/predictions/helpers.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_PREDICTION } from 'config/constants/endpoints'\nimport { ethers } from 'ethers'\nimport {\n  Bet,\n  LedgerData,\n  BetPosition,\n  PredictionsState,\n  PredictionStatus,\n  ReduxNodeLedger,\n  ReduxNodeRound,\n  Round,\n  RoundData,\n} from 'state/types'\nimport { multicallv2 } from 'utils/multicall'\nimport predictionsAbi from 'config/abi/predictions.json'\nimport { getPredictionsAddress } from 'utils/addressHelpers'\nimport { PredictionsClaimableResponse, PredictionsLedgerResponse, PredictionsRoundsResponse } from 'utils/types'\nimport {\n  BetResponse,\n  getRoundBaseFields,\n  getBetBaseFields,\n  getUserBaseFields,\n  RoundResponse,\n  TotalWonMarketResponse,\n  TotalWonRoundResponse,\n} from './queries'\n\nexport enum Result {\n  WIN = 'win',\n  LOSE = 'lose',\n  CANCELED = 'canceled',\n  LIVE = 'live',\n}\n\nexport const numberOrNull = (value: string) => {\n  if (value === null) {\n    return null\n  }\n\n  const valueNum = Number(value)\n  return Number.isNaN(valueNum) ? null : valueNum\n}\n\nexport const transformBetResponse = (betResponse: BetResponse): Bet => {\n  const bet = {\n    id: betResponse.id,\n    hash: betResponse.hash,\n    amount: betResponse.amount ? parseFloat(betResponse.amount) : 0,\n    position: betResponse.position === 'Bull' ? BetPosition.BULL : BetPosition.BEAR,\n    claimed: betResponse.claimed,\n    claimedHash: betResponse.claimedHash,\n    user: {\n      id: betResponse.user.id,\n      address: betResponse.user.address,\n      block: numberOrNull(betResponse.user.block),\n      totalBets: numberOrNull(betResponse.user.totalBets),\n      totalBNB: numberOrNull(betResponse.user.totalBNB),\n    },\n  } as Bet\n\n  if (betResponse.round) {\n    bet.round = transformRoundResponse(betResponse.round)\n  }\n\n  return bet\n}\n\nexport const transformRoundResponse = (roundResponse: RoundResponse): Round => {\n  const {\n    id,\n    epoch,\n    failed,\n    startBlock,\n    startAt,\n    lockAt,\n    lockBlock,\n    lockPrice,\n    endBlock,\n    closePrice,\n    totalBets,\n    totalAmount,\n    bullBets,\n    bearBets,\n    bearAmount,\n    bullAmount,\n    position,\n    bets = [],\n  } = roundResponse\n\n  const getRoundPosition = (positionResponse: string) => {\n    if (positionResponse === 'Bull') {\n      return BetPosition.BULL\n    }\n\n    if (positionResponse === 'Bear') {\n      return BetPosition.BEAR\n    }\n\n    return null\n  }\n\n  return {\n    id,\n    failed,\n    epoch: numberOrNull(epoch),\n    startBlock: numberOrNull(startBlock),\n    startAt: numberOrNull(startAt),\n    lockAt: numberOrNull(lockAt),\n    lockBlock: numberOrNull(lockBlock),\n    lockPrice: lockPrice ? parseFloat(lockPrice) : null,\n    endBlock: numberOrNull(endBlock),\n    closePrice: closePrice ? parseFloat(closePrice) : null,\n    totalBets: numberOrNull(totalBets),\n    totalAmount: totalAmount ? parseFloat(totalAmount) : 0,\n    bullBets: numberOrNull(bullBets),\n    bearBets: numberOrNull(bearBets),\n    bearAmount: numberOrNull(bearAmount),\n    bullAmount: numberOrNull(bullAmount),\n    position: getRoundPosition(position),\n    bets: bets.map(transformBetResponse),\n  }\n}\n\nexport const transformTotalWonResponse = (\n  marketResponse: TotalWonMarketResponse,\n  roundResponse: TotalWonRoundResponse[],\n): number => {\n  const houseRounds = roundResponse.reduce((accum, round) => {\n    return accum + (round.totalAmount ? parseFloat(round.totalAmount) : 0)\n  }, 0)\n\n  const totalBNB = marketResponse.totalBNB ? parseFloat(marketResponse.totalBNB) : 0\n  const totalBNBTreasury = marketResponse.totalBNBTreasury ? parseFloat(marketResponse.totalBNBTreasury) : 0\n\n  return Math.max(totalBNB - (totalBNBTreasury + houseRounds), 0)\n}\n\nexport const getRoundResult = (bet: Bet, currentEpoch: number): Result => {\n  const { round } = bet\n  if (round.failed) {\n    return Result.CANCELED\n  }\n\n  if (round.epoch >= currentEpoch - 1) {\n    return Result.LIVE\n  }\n  const roundResultPosition = round.closePrice > round.lockPrice ? BetPosition.BULL : BetPosition.BEAR\n\n  return bet.position === roundResultPosition ? Result.WIN : Result.LOSE\n}\n\n/**\n * Given a bet object, check if it is eligible to be claimed or refunded\n */\nexport const getCanClaim = (bet: Bet) => {\n  return !bet.claimed && (bet.position === bet.round.position || bet.round.failed === true)\n}\n\n/**\n * Returns only bets where the user has won.\n * This is necessary because the API currently cannot distinguish between an uncliamed bet that has won or lost\n */\nexport const getUnclaimedWinningBets = (bets: Bet[]): Bet[] => {\n  return bets.filter(getCanClaim)\n}\n\nexport const getTotalWon = async (): Promise<number> => {\n  const response = (await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getTotalWonData($position: String) {\n        market(id: 1) {\n          totalBNB\n          totalBNBTreasury\n        }\n        rounds(where: { position: $position }) {\n          totalAmount\n        }\n      }\n    `,\n    { position: BetPosition.HOUSE },\n  )) as { market: TotalWonMarketResponse; rounds: TotalWonRoundResponse[] }\n\n  return transformTotalWonResponse(response.market, response.rounds)\n}\n\ntype BetHistoryWhereClause = Record<string, string | number | boolean | string[]>\n\nexport const getBetHistory = async (\n  where: BetHistoryWhereClause = {},\n  first = 1000,\n  skip = 0,\n): Promise<BetResponse[]> => {\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getBetHistory($first: Int!, $skip: Int!, $where: Bet_filter) {\n        bets(first: $first, skip: $skip, where: $where, order: createdAt, orderDirection: desc) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n    `,\n    { first, skip, where },\n  )\n  return response.bets\n}\n\nexport const getBet = async (betId: string): Promise<BetResponse> => {\n  const response = await request(\n    GRAPH_API_PREDICTION,\n    gql`\n      query getBet($id: ID!) {\n        bet(id: $id) {\n          ${getBetBaseFields()}\n          round {\n            ${getRoundBaseFields()}\n          }\n          user {\n            ${getUserBaseFields()}\n          } \n        }\n      }\n  `,\n    {\n      id: betId.toLowerCase(),\n    },\n  )\n  return response.bet\n}\n\n// V2 REFACTOR\nexport const getLedgerData = async (account: string, epochs: number[]) => {\n  const address = getPredictionsAddress()\n  const ledgerCalls = epochs.map((epoch) => ({\n    address,\n    name: 'ledger',\n    params: [epoch, account],\n  }))\n  const response = await multicallv2<PredictionsLedgerResponse[]>(predictionsAbi, ledgerCalls)\n  return response\n}\n\nexport const getClaimStatuses = async (\n  account: string,\n  epochs: number[],\n): Promise<PredictionsState['claimableStatuses']> => {\n  const address = getPredictionsAddress()\n  const claimableCalls = epochs.map((epoch) => ({\n    address,\n    name: 'claimable',\n    params: [epoch, account],\n  }))\n  const claimableResponses = await multicallv2<[PredictionsClaimableResponse][]>(predictionsAbi, claimableCalls)\n\n  // \"claimable\" currently has a bug where it returns true on Bull bets even if the wallet did not interact with the round\n  // To get around this temporarily we check the ledger status as well to confirm that it is claimable\n  // This can be removed in Predictions V2\n  const ledgerResponses = await getLedgerData(account, epochs)\n\n  return claimableResponses.reduce((accum, claimableResponse, index) => {\n    const { amount, claimed } = ledgerResponses[index]\n    const epoch = epochs[index]\n    const [claimable] = claimableResponse\n\n    return {\n      ...accum,\n      [epoch]: claimable && amount.gt(0) && !claimed,\n    }\n  }, {})\n}\n\nexport type MarketData = Pick<\n  PredictionsState,\n  'status' | 'currentEpoch' | 'intervalBlocks' | 'bufferBlocks' | 'minBetAmount' | 'rewardRate'\n>\nexport const getPredictionData = async (): Promise<MarketData> => {\n  const address = getPredictionsAddress()\n  const staticCalls = ['currentEpoch', 'intervalBlocks', 'minBetAmount', 'paused', 'bufferBlocks', 'rewardRate'].map(\n    (method) => ({\n      address,\n      name: method,\n    }),\n  )\n  const [[currentEpoch], [intervalBlocks], [minBetAmount], [paused], [bufferBlocks], [rewardRate]] = await multicallv2(\n    predictionsAbi,\n    staticCalls,\n  )\n\n  return {\n    status: paused ? PredictionStatus.PAUSED : PredictionStatus.LIVE,\n    currentEpoch: currentEpoch.toNumber(),\n    intervalBlocks: intervalBlocks.toNumber(),\n    bufferBlocks: bufferBlocks.toNumber(),\n    minBetAmount: minBetAmount.toString(),\n    rewardRate: rewardRate.toNumber(),\n  }\n}\n\nexport const getRoundsData = async (epochs: number[]): Promise<PredictionsRoundsResponse[]> => {\n  const address = getPredictionsAddress()\n  const calls = epochs.map((epoch) => ({\n    address,\n    name: 'rounds',\n    params: [epoch],\n  }))\n  const response = await multicallv2<PredictionsRoundsResponse[]>(predictionsAbi, calls)\n  return response\n}\n\nexport const makeFutureRoundResponse = (epoch: number, startBlock: number): ReduxNodeRound => {\n  return {\n    epoch,\n    startBlock,\n    lockBlock: null,\n    endBlock: null,\n    lockPrice: null,\n    closePrice: null,\n    totalAmount: ethers.BigNumber.from(0).toJSON(),\n    bullAmount: ethers.BigNumber.from(0).toJSON(),\n    bearAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardBaseCalAmount: ethers.BigNumber.from(0).toJSON(),\n    rewardAmount: ethers.BigNumber.from(0).toJSON(),\n    oracleCalled: false,\n  }\n}\n\nexport const makeRoundData = (rounds: ReduxNodeRound[]): RoundData => {\n  return rounds.reduce((accum, round) => {\n    return {\n      ...accum,\n      [round.epoch.toString()]: round,\n    }\n  }, {})\n}\n\nexport const serializePredictionsLedgerResponse = (ledgerResponse: PredictionsLedgerResponse): ReduxNodeLedger => ({\n  position: ledgerResponse.position === 0 ? BetPosition.BULL : BetPosition.BEAR,\n  amount: ledgerResponse.amount.toJSON(),\n  claimed: ledgerResponse.claimed,\n})\n\nexport const makeLedgerData = (account: string, ledgers: PredictionsLedgerResponse[], epochs: number[]): LedgerData => {\n  return ledgers.reduce((accum, ledgerResponse, index) => {\n    if (!ledgerResponse) {\n      return accum\n    }\n\n    // If the amount is zero that means the user did not bet\n    if (ledgerResponse.amount.eq(0)) {\n      return accum\n    }\n\n    const epoch = epochs[index].toString()\n\n    return {\n      ...accum,\n      [account]: {\n        ...accum[account],\n        [epoch]: serializePredictionsLedgerResponse(ledgerResponse),\n      },\n    }\n  }, {})\n}\n\n/**\n * Serializes the return from the \"rounds\" call for redux\n */\nexport const serializePredictionsRoundsResponse = (response: PredictionsRoundsResponse): ReduxNodeRound => {\n  const {\n    epoch,\n    startBlock,\n    lockBlock,\n    endBlock,\n    lockPrice,\n    closePrice,\n    totalAmount,\n    bullAmount,\n    bearAmount,\n    rewardAmount,\n    rewardBaseCalAmount,\n    oracleCalled,\n  } = response\n\n  return {\n    epoch: epoch.toNumber(),\n    startBlock: startBlock.toNumber(),\n    lockBlock: lockBlock.toNumber(),\n    endBlock: endBlock.toNumber(),\n    lockPrice: lockPrice.eq(0) ? null : lockPrice.toJSON(),\n    closePrice: closePrice.eq(0) ? null : closePrice.toJSON(),\n    totalAmount: totalAmount.toJSON(),\n    bullAmount: bullAmount.toJSON(),\n    bearAmount: bearAmount.toJSON(),\n    rewardAmount: rewardAmount.toJSON(),\n    rewardBaseCalAmount: rewardBaseCalAmount.toJSON(),\n    oracleCalled,\n  }\n}\n\n/**\n * Parse serialized values back into ethers.BigNumber\n * ethers.BigNumber values are stored with the \"toJSJON()\" method, e.g  { type: \"BigNumber\", hex: string }\n */\nexport const parseBigNumberObj = <T = Record<string, any>, K = Record<string, any>>(data: T): K => {\n  return Object.keys(data).reduce((accum, key) => {\n    const value = data[key]\n\n    if (value && value?.type === 'BigNumber') {\n      return {\n        ...accum,\n        [key]: ethers.BigNumber.from(value),\n      }\n    }\n\n    return {\n      ...accum,\n      [key]: value,\n    }\n  }, {}) as K\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}