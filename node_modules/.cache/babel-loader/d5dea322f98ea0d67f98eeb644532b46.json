{"ast":null,"code":"/* eslint-disable consistent-return */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable no-bitwise */\n/* eslint-disable one-var */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning';\nimport JSBI from 'jsbi';\nimport { getAddress } from '@ethersproject/address';\nimport { ZERO, ONE, TWO, THREE, SolidityType } from './constants';\nexport function validateSolidityTypeInstance(value, solidityType) {\n  // invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  // invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address) {\n  try {\n    const checksummedAddress = getAddress(address);\n    warning(address === checksummedAddress, `${address} is not checksummed.`);\n    return checksummedAddress;\n  } catch (error) {\n    // invariant(false, `${address} is not a valid address.`)\n  }\n}\nexport function parseBigintIsh(bigintIsh) {\n  return bigintIsh instanceof JSBI ? bigintIsh : typeof bigintIsh === 'bigint' ? JSBI.BigInt(bigintIsh.toString()) : JSBI.BigInt(bigintIsh);\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y) {\n  validateSolidityTypeInstance(y, SolidityType.uint256);\n  let z = ZERO;\n  let x;\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y;\n    x = JSBI.add(JSBI.divide(y, TWO), ONE);\n    while (JSBI.lessThan(x, z)) {\n      z = x;\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO);\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE;\n  }\n  return z;\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert(items, add, maxSize, comparator) {\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add);\n    return null;\n  } else {\n    const isFull = items.length === maxSize;\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add;\n    }\n    let lo = 0,\n      hi = items.length;\n    while (lo < hi) {\n      const mid = lo + hi >>> 1;\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1;\n      } else {\n        hi = mid;\n      }\n    }\n    items.splice(lo, 0, add);\n    return isFull ? items.pop() : null;\n  }\n}","map":{"version":3,"names":["warning","JSBI","getAddress","ZERO","ONE","TWO","THREE","SolidityType","validateSolidityTypeInstance","value","solidityType","validateAndParseAddress","address","checksummedAddress","error","parseBigintIsh","bigintIsh","BigInt","toString","sqrt","y","uint256","z","x","greaterThan","add","divide","lessThan","notEqual","sortedInsert","items","maxSize","comparator","length","push","isFull","lo","hi","mid","splice","pop"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/utils.ts"],"sourcesContent":["/* eslint-disable consistent-return */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\n/* eslint-disable no-bitwise */\n/* eslint-disable one-var */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport JSBI from 'jsbi'\nimport { getAddress } from '@ethersproject/address'\n\nimport { BigintIsh, ZERO, ONE, TWO, THREE, SolidityType, SOLIDITY_TYPE_MAXIMA } from './constants'\n\nexport function validateSolidityTypeInstance(value: JSBI, solidityType: SolidityType): void {\n  // invariant(JSBI.greaterThanOrEqual(value, ZERO), `${value} is not a ${solidityType}.`)\n  // invariant(JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]), `${value} is not a ${solidityType}.`)\n}\n\n// warns if addresses are not checksummed\nexport function validateAndParseAddress(address: string): string {\n  try {\n    const checksummedAddress = getAddress(address)\n    warning(address === checksummedAddress, `${address} is not checksummed.`)\n    return checksummedAddress\n  } catch (error) {\n    // invariant(false, `${address} is not a valid address.`)\n  }\n}\n\nexport function parseBigintIsh(bigintIsh: BigintIsh): JSBI {\n  return bigintIsh instanceof JSBI\n    ? bigintIsh\n    : typeof bigintIsh === 'bigint'\n    ? JSBI.BigInt(bigintIsh.toString())\n    : JSBI.BigInt(bigintIsh)\n}\n\n// mock the on-chain sqrt function\nexport function sqrt(y: JSBI): JSBI {\n  validateSolidityTypeInstance(y, SolidityType.uint256)\n  let z: JSBI = ZERO\n  let x: JSBI\n  if (JSBI.greaterThan(y, THREE)) {\n    z = y\n    x = JSBI.add(JSBI.divide(y, TWO), ONE)\n    while (JSBI.lessThan(x, z)) {\n      z = x\n      x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO)\n    }\n  } else if (JSBI.notEqual(y, ZERO)) {\n    z = ONE\n  }\n  return z\n}\n\n// given an array of items sorted by `comparator`, insert an item into its sort index and constrain the size to\n// `maxSize` by removing the last item\nexport function sortedInsert<T>(items: T[], add: T, maxSize: number, comparator: (a: T, b: T) => number): T | null {\n\n\n  // short circuit first item add\n  if (items.length === 0) {\n    items.push(add)\n    return null\n  } else {\n    const isFull = items.length === maxSize\n    // short circuit if full and the additional item does not come before the last item\n    if (isFull && comparator(items[items.length - 1], add) <= 0) {\n      return add\n    }\n\n    let lo = 0,\n      hi = items.length\n\n    while (lo < hi) {\n      const mid = (lo + hi) >>> 1\n      if (comparator(items[mid], add) <= 0) {\n        lo = mid + 1\n      } else {\n        hi = mid\n      }\n    }\n    items.splice(lo, 0, add)\n    return isFull ? items.pop()! : null\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}