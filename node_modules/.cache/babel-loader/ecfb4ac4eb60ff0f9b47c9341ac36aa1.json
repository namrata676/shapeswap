{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport farmsConfig from 'config/constants/farms';\nimport isArchivedPid from 'utils/farmHelpers';\nimport fetchFarms from './fetchFarms';\nimport fetchFarmsPrices from './fetchFarmsPrices';\nimport { fetchFarmUserEarnings, fetchFarmUserAllowances, fetchFarmUserTokenBalances, fetchFarmUserStakedBalances } from './fetchFarmUser';\nconst noAccountFarmConfig = farmsConfig.map(farm => ({\n  ...farm,\n  userData: {\n    allowance: '0',\n    tokenBalance: '0',\n    stakedBalance: '0',\n    earnings: '0'\n  }\n}));\nconst initialState = {\n  data: noAccountFarmConfig,\n  loadArchivedFarmsData: false,\n  userDataLoaded: false\n};\nexport const nonArchivedFarms = farmsConfig.filter(_ref => {\n  let {\n    pid\n  } = _ref;\n  return !isArchivedPid(pid);\n});\n\n// Async thunks\nexport const fetchFarmsPublicDataAsync = createAsyncThunk('farms/fetchFarmsPublicDataAsync', async pids => {\n  const farmsToFetch = farmsConfig.filter(farmConfig => pids.includes(farmConfig.pid));\n\n  // Add price helper farms\n  // const farmsWithPriceHelpers = farmsToFetch.concat(priceHelperLpsConfig)\n  // const farmsWithPriceHelpers = farmsToFetch\n\n  const farms = await fetchFarms(farmsToFetch);\n  const farmsWithPrices = await fetchFarmsPrices(farms);\n\n  // Filter out price helper LP config farms\n  // const farmsWithoutHelperLps = farmsWithPrices.filter((farm: Farm) => {\n  //   return farm.pid || farm.pid === 0\n  // })\n  return farmsWithPrices;\n});\nexport const fetchFarmUserDataAsync = createAsyncThunk('farms/fetchFarmUserDataAsync', async _ref2 => {\n  let {\n    account,\n    pids\n  } = _ref2;\n  const farmsToFetch = farmsConfig.filter(farmConfig => pids.includes(farmConfig.pid));\n  const userFarmAllowances = await fetchFarmUserAllowances(account, farmsToFetch);\n  const userFarmTokenBalances = await fetchFarmUserTokenBalances(account, farmsToFetch);\n  const userFarmEarnings = await fetchFarmUserEarnings(account, farmsToFetch);\n  const userStakedBalances = await fetchFarmUserStakedBalances(account, farmsToFetch);\n  return userFarmAllowances.map((farmAllowance, index) => {\n    return {\n      pid: farmsToFetch[index].pid,\n      allowance: userFarmAllowances[index],\n      tokenBalance: userFarmTokenBalances[index],\n      stakedBalance: userStakedBalances[index],\n      earnings: userFarmEarnings[index]\n    };\n  });\n});\nexport const farmsSlice = createSlice({\n  name: 'Farms',\n  initialState,\n  reducers: {\n    setLoadArchivedFarmsData: (state, action) => {\n      const loadArchivedFarmsData = action.payload;\n      state.loadArchivedFarmsData = loadArchivedFarmsData;\n    }\n  },\n  extraReducers: builder => {\n    // Update farms with live data\n    builder.addCase(fetchFarmsPublicDataAsync.fulfilled, (state, action) => {\n      state.data = state.data.map(farm => {\n        const liveFarmData = action.payload.find(farmData => farmData.pid === farm.pid);\n        return {\n          ...farm,\n          ...liveFarmData\n        };\n      });\n    });\n\n    // Update farms with user data\n    builder.addCase(fetchFarmUserDataAsync.fulfilled, (state, action) => {\n      action.payload.forEach(userDataEl => {\n        const {\n          pid\n        } = userDataEl;\n        const index = state.data.findIndex(farm => farm.pid === pid);\n        state.data[index] = {\n          ...state.data[index],\n          userData: userDataEl\n        };\n      });\n      state.userDataLoaded = true;\n    });\n  }\n});\n\n// Actions\nexport const {\n  setLoadArchivedFarmsData\n} = farmsSlice.actions;\nexport default farmsSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","farmsConfig","isArchivedPid","fetchFarms","fetchFarmsPrices","fetchFarmUserEarnings","fetchFarmUserAllowances","fetchFarmUserTokenBalances","fetchFarmUserStakedBalances","noAccountFarmConfig","map","farm","userData","allowance","tokenBalance","stakedBalance","earnings","initialState","data","loadArchivedFarmsData","userDataLoaded","nonArchivedFarms","filter","pid","fetchFarmsPublicDataAsync","pids","farmsToFetch","farmConfig","includes","farms","farmsWithPrices","fetchFarmUserDataAsync","account","userFarmAllowances","userFarmTokenBalances","userFarmEarnings","userStakedBalances","farmAllowance","index","farmsSlice","name","reducers","setLoadArchivedFarmsData","state","action","payload","extraReducers","builder","addCase","fulfilled","liveFarmData","find","farmData","forEach","userDataEl","findIndex","actions","reducer"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/state/farms/index.ts"],"sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport farmsConfig from 'config/constants/farms'\nimport isArchivedPid from 'utils/farmHelpers'\nimport priceHelperLpsConfig from 'config/constants/priceHelperLps'\nimport fetchFarms from './fetchFarms'\nimport fetchFarmsPrices from './fetchFarmsPrices'\nimport {\n  fetchFarmUserEarnings,\n  fetchFarmUserAllowances,\n  fetchFarmUserTokenBalances,\n  fetchFarmUserStakedBalances,\n} from './fetchFarmUser'\nimport { FarmsState, Farm } from '../types'\n\nconst noAccountFarmConfig = farmsConfig.map((farm) => ({\n  ...farm,\n  userData: {\n    allowance: '0',\n    tokenBalance: '0',\n    stakedBalance: '0',\n    earnings: '0',\n  },\n}))\n\nconst initialState: FarmsState = { data: noAccountFarmConfig, loadArchivedFarmsData: false, userDataLoaded: false }\n\nexport const nonArchivedFarms = farmsConfig.filter(({ pid }) => !isArchivedPid(pid))\n\n// Async thunks\nexport const fetchFarmsPublicDataAsync = createAsyncThunk<Farm[], number[]>(\n  'farms/fetchFarmsPublicDataAsync',\n  async (pids) => {\n    const farmsToFetch = farmsConfig.filter((farmConfig) => pids.includes(farmConfig.pid))\n\n    // Add price helper farms\n    // const farmsWithPriceHelpers = farmsToFetch.concat(priceHelperLpsConfig)\n    // const farmsWithPriceHelpers = farmsToFetch\n\n    const farms = await fetchFarms(farmsToFetch)\n    const farmsWithPrices = await fetchFarmsPrices(farms)\n\n    // Filter out price helper LP config farms\n    // const farmsWithoutHelperLps = farmsWithPrices.filter((farm: Farm) => {\n    //   return farm.pid || farm.pid === 0\n    // })\n    return farmsWithPrices\n  },\n)\n\ninterface FarmUserDataResponse {\n  pid: number\n  allowance: string\n  tokenBalance: string\n  stakedBalance: string\n  earnings: string\n}\n\nexport const fetchFarmUserDataAsync = createAsyncThunk<FarmUserDataResponse[], { account: string; pids: number[] }>(\n  'farms/fetchFarmUserDataAsync',\n  async ({ account, pids }) => {\n    const farmsToFetch = farmsConfig.filter((farmConfig) => pids.includes(farmConfig.pid))\n    const userFarmAllowances = await fetchFarmUserAllowances(account, farmsToFetch)\n    const userFarmTokenBalances = await fetchFarmUserTokenBalances(account, farmsToFetch)\n    const userFarmEarnings = await fetchFarmUserEarnings(account, farmsToFetch)\n    const userStakedBalances = await fetchFarmUserStakedBalances(account, farmsToFetch)\n\n\n    return userFarmAllowances.map((farmAllowance, index) => {\n      return {\n        pid: farmsToFetch[index].pid,\n        allowance: userFarmAllowances[index],\n        tokenBalance: userFarmTokenBalances[index],\n        stakedBalance: userStakedBalances[index],\n        earnings: userFarmEarnings[index],\n      }\n    })\n  },\n)\n\nexport const farmsSlice = createSlice({\n  name: 'Farms',\n  initialState,\n  reducers: {\n    setLoadArchivedFarmsData: (state, action) => {\n      const loadArchivedFarmsData = action.payload\n      state.loadArchivedFarmsData = loadArchivedFarmsData\n    },\n  },\n  \n  \n  extraReducers: (builder) => {\n    // Update farms with live data\n    builder.addCase(fetchFarmsPublicDataAsync.fulfilled, (state, action) => {\n      state.data = state.data.map((farm) => {\n        const liveFarmData = action.payload.find((farmData) => farmData.pid === farm.pid)\n        return { ...farm, ...liveFarmData }\n      })\n    })\n\n    // Update farms with user data\n    builder.addCase(fetchFarmUserDataAsync.fulfilled, (state, action) => {\n      action.payload.forEach((userDataEl) => {\n        const { pid } = userDataEl\n        const index = state.data.findIndex((farm) => farm.pid === pid)\n        state.data[index] = { ...state.data[index], userData: userDataEl }\n      })\n      state.userDataLoaded = true\n    })\n  },\n})\n\n// Actions\nexport const { setLoadArchivedFarmsData } = farmsSlice.actions\n\nexport default farmsSlice.reducer\n"],"mappings":"AAAA,SAASA,gBAAgB,EAAEC,WAAW,QAAQ,kBAAkB;AAChE,OAAOC,WAAW,MAAM,wBAAwB;AAChD,OAAOC,aAAa,MAAM,mBAAmB;AAE7C,OAAOC,UAAU,MAAM,cAAc;AACrC,OAAOC,gBAAgB,MAAM,oBAAoB;AACjD,SACEC,qBAAqB,EACrBC,uBAAuB,EACvBC,0BAA0B,EAC1BC,2BAA2B,QACtB,iBAAiB;AAGxB,MAAMC,mBAAmB,GAAGR,WAAW,CAACS,GAAG,CAAEC,IAAI,KAAM;EACrD,GAAGA,IAAI;EACPC,QAAQ,EAAE;IACRC,SAAS,EAAE,GAAG;IACdC,YAAY,EAAE,GAAG;IACjBC,aAAa,EAAE,GAAG;IAClBC,QAAQ,EAAE;EACZ;AACF,CAAC,CAAC,CAAC;AAEH,MAAMC,YAAwB,GAAG;EAAEC,IAAI,EAAET,mBAAmB;EAAEU,qBAAqB,EAAE,KAAK;EAAEC,cAAc,EAAE;AAAM,CAAC;AAEnH,OAAO,MAAMC,gBAAgB,GAAGpB,WAAW,CAACqB,MAAM,CAAC;EAAA,IAAC;IAAEC;EAAI,CAAC;EAAA,OAAK,CAACrB,aAAa,CAACqB,GAAG,CAAC;AAAA,EAAC;;AAEpF;AACA,OAAO,MAAMC,yBAAyB,GAAGzB,gBAAgB,CACvD,iCAAiC,EACjC,MAAO0B,IAAI,IAAK;EACd,MAAMC,YAAY,GAAGzB,WAAW,CAACqB,MAAM,CAAEK,UAAU,IAAKF,IAAI,CAACG,QAAQ,CAACD,UAAU,CAACJ,GAAG,CAAC,CAAC;;EAEtF;EACA;EACA;;EAEA,MAAMM,KAAK,GAAG,MAAM1B,UAAU,CAACuB,YAAY,CAAC;EAC5C,MAAMI,eAAe,GAAG,MAAM1B,gBAAgB,CAACyB,KAAK,CAAC;;EAErD;EACA;EACA;EACA;EACA,OAAOC,eAAe;AACxB,CAAC,CACF;AAUD,OAAO,MAAMC,sBAAsB,GAAGhC,gBAAgB,CACpD,8BAA8B,EAC9B,eAA6B;EAAA,IAAtB;IAAEiC,OAAO;IAAEP;EAAK,CAAC;EACtB,MAAMC,YAAY,GAAGzB,WAAW,CAACqB,MAAM,CAAEK,UAAU,IAAKF,IAAI,CAACG,QAAQ,CAACD,UAAU,CAACJ,GAAG,CAAC,CAAC;EACtF,MAAMU,kBAAkB,GAAG,MAAM3B,uBAAuB,CAAC0B,OAAO,EAAEN,YAAY,CAAC;EAC/E,MAAMQ,qBAAqB,GAAG,MAAM3B,0BAA0B,CAACyB,OAAO,EAAEN,YAAY,CAAC;EACrF,MAAMS,gBAAgB,GAAG,MAAM9B,qBAAqB,CAAC2B,OAAO,EAAEN,YAAY,CAAC;EAC3E,MAAMU,kBAAkB,GAAG,MAAM5B,2BAA2B,CAACwB,OAAO,EAAEN,YAAY,CAAC;EAGnF,OAAOO,kBAAkB,CAACvB,GAAG,CAAC,CAAC2B,aAAa,EAAEC,KAAK,KAAK;IACtD,OAAO;MACLf,GAAG,EAAEG,YAAY,CAACY,KAAK,CAAC,CAACf,GAAG;MAC5BV,SAAS,EAAEoB,kBAAkB,CAACK,KAAK,CAAC;MACpCxB,YAAY,EAAEoB,qBAAqB,CAACI,KAAK,CAAC;MAC1CvB,aAAa,EAAEqB,kBAAkB,CAACE,KAAK,CAAC;MACxCtB,QAAQ,EAAEmB,gBAAgB,CAACG,KAAK;IAClC,CAAC;EACH,CAAC,CAAC;AACJ,CAAC,CACF;AAED,OAAO,MAAMC,UAAU,GAAGvC,WAAW,CAAC;EACpCwC,IAAI,EAAE,OAAO;EACbvB,YAAY;EACZwB,QAAQ,EAAE;IACRC,wBAAwB,EAAE,CAACC,KAAK,EAAEC,MAAM,KAAK;MAC3C,MAAMzB,qBAAqB,GAAGyB,MAAM,CAACC,OAAO;MAC5CF,KAAK,CAACxB,qBAAqB,GAAGA,qBAAqB;IACrD;EACF,CAAC;EAGD2B,aAAa,EAAGC,OAAO,IAAK;IAC1B;IACAA,OAAO,CAACC,OAAO,CAACxB,yBAAyB,CAACyB,SAAS,EAAE,CAACN,KAAK,EAAEC,MAAM,KAAK;MACtED,KAAK,CAACzB,IAAI,GAAGyB,KAAK,CAACzB,IAAI,CAACR,GAAG,CAAEC,IAAI,IAAK;QACpC,MAAMuC,YAAY,GAAGN,MAAM,CAACC,OAAO,CAACM,IAAI,CAAEC,QAAQ,IAAKA,QAAQ,CAAC7B,GAAG,KAAKZ,IAAI,CAACY,GAAG,CAAC;QACjF,OAAO;UAAE,GAAGZ,IAAI;UAAE,GAAGuC;QAAa,CAAC;MACrC,CAAC,CAAC;IACJ,CAAC,CAAC;;IAEF;IACAH,OAAO,CAACC,OAAO,CAACjB,sBAAsB,CAACkB,SAAS,EAAE,CAACN,KAAK,EAAEC,MAAM,KAAK;MACnEA,MAAM,CAACC,OAAO,CAACQ,OAAO,CAAEC,UAAU,IAAK;QACrC,MAAM;UAAE/B;QAAI,CAAC,GAAG+B,UAAU;QAC1B,MAAMhB,KAAK,GAAGK,KAAK,CAACzB,IAAI,CAACqC,SAAS,CAAE5C,IAAI,IAAKA,IAAI,CAACY,GAAG,KAAKA,GAAG,CAAC;QAC9DoB,KAAK,CAACzB,IAAI,CAACoB,KAAK,CAAC,GAAG;UAAE,GAAGK,KAAK,CAACzB,IAAI,CAACoB,KAAK,CAAC;UAAE1B,QAAQ,EAAE0C;QAAW,CAAC;MACpE,CAAC,CAAC;MACFX,KAAK,CAACvB,cAAc,GAAG,IAAI;IAC7B,CAAC,CAAC;EACJ;AACF,CAAC,CAAC;;AAEF;AACA,OAAO,MAAM;EAAEsB;AAAyB,CAAC,GAAGH,UAAU,CAACiB,OAAO;AAE9D,eAAejB,UAAU,CAACkB,OAAO"},"metadata":{},"sourceType":"module"}