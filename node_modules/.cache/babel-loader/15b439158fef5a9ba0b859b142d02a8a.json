{"ast":null,"code":"import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts';\nimport { getAddress } from './addressHelpers';\nimport { getErc721Contract } from './contractHelpers';\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = nftAddress => {\n  const nftSource = Object.values(nftSources).find(nftSourceEntry => {\n    const address = getAddress(nftSourceEntry.address);\n    return address === nftAddress;\n  });\n  return nftSource ? nftSource.identifierKey : null;\n};\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = tokenUri => {\n  if (tokenUri.startsWith('ipfs://')) {\n    return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`;\n  }\n  return tokenUri;\n};\nexport const getAddressByType = type => {\n  return getAddress(nftSources[type].address);\n};\nexport const getTokenUriData = async (nftAddress, tokenId) => {\n  try {\n    const contract = getErc721Contract(nftAddress);\n    const tokenUri = await contract.tokenURI(tokenId);\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri));\n    if (!uriDataResponse.ok) {\n      return null;\n    }\n    const uriData = await uriDataResponse.json();\n    return uriData;\n  } catch (error) {\n    console.error('getTokenUriData', error);\n    return null;\n  }\n};\nexport const getNftByTokenId = async (nftAddress, tokenId) => {\n  const uriData = await getTokenUriData(nftAddress, tokenId);\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress);\n\n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  if (!uriData) {\n    return null;\n  }\n  if (!identifierKey) {\n    return null;\n  }\n  if (!uriData[identifierKey]) {\n    return null;\n  }\n  return Nfts.find(nft => {\n    return uriData[identifierKey].includes(nft.identifier);\n  });\n};","map":{"version":3,"names":["Nfts","IPFS_GATEWAY","nftSources","getAddress","getErc721Contract","getIdentifierKeyFromAddress","nftAddress","nftSource","Object","values","find","nftSourceEntry","address","identifierKey","getTokenUrl","tokenUri","startsWith","slice","getAddressByType","type","getTokenUriData","tokenId","contract","tokenURI","uriDataResponse","fetch","ok","uriData","json","error","console","getNftByTokenId","nft","includes","identifier"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/utils/collectibles.ts"],"sourcesContent":["import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts'\nimport { Nft, NftType } from 'config/constants/types'\nimport { getAddress } from './addressHelpers'\nimport { getErc721Contract } from './contractHelpers'\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = (nftAddress: string) => {\n  const nftSource = Object.values(nftSources).find((nftSourceEntry) => {\n    const address = getAddress(nftSourceEntry.address)\n    return address === nftAddress\n  })\n\n  return nftSource ? nftSource.identifierKey : null\n}\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = (tokenUri: string) => {\n  if (tokenUri.startsWith('ipfs://')) {\n    return `${IPFS_GATEWAY}/ipfs/${tokenUri.slice(6)}`\n  }\n\n  return tokenUri\n}\n\nexport const getAddressByType = (type: NftType) => {\n  return getAddress(nftSources[type].address)\n}\n\nexport const getTokenUriData = async (nftAddress: string, tokenId: number) => {\n  try {\n    const contract = getErc721Contract(nftAddress)\n    const tokenUri = await contract.tokenURI(tokenId)\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri))\n\n    if (!uriDataResponse.ok) {\n      return null\n    }\n\n    const uriData = await uriDataResponse.json()\n    return uriData\n  } catch (error) {\n    console.error('getTokenUriData', error)\n    return null\n  }\n}\n\nexport const getNftByTokenId = async (nftAddress: string, tokenId: number): Promise<Nft | null> => {\n  const uriData = await getTokenUriData(nftAddress, tokenId)\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress)\n\n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  if (!uriData) {\n    return null\n  }\n\n  if (!identifierKey) {\n    return null\n  }\n\n  if (!uriData[identifierKey]) {\n    return null\n  }\n\n  return Nfts.find((nft) => {\n    return uriData[identifierKey].includes(nft.identifier)\n  })\n}\n"],"mappings":"AAAA,OAAOA,IAAI,IAAIC,YAAY,EAAEC,UAAU,QAAQ,uBAAuB;AAEtE,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,iBAAiB,QAAQ,mBAAmB;;AAErD;AACA;AACA;AACA;AACA,OAAO,MAAMC,2BAA2B,GAAIC,UAAkB,IAAK;EACjE,MAAMC,SAAS,GAAGC,MAAM,CAACC,MAAM,CAACP,UAAU,CAAC,CAACQ,IAAI,CAAEC,cAAc,IAAK;IACnE,MAAMC,OAAO,GAAGT,UAAU,CAACQ,cAAc,CAACC,OAAO,CAAC;IAClD,OAAOA,OAAO,KAAKN,UAAU;EAC/B,CAAC,CAAC;EAEF,OAAOC,SAAS,GAAGA,SAAS,CAACM,aAAa,GAAG,IAAI;AACnD,CAAC;;AAED;AACA;AACA;AACA,OAAO,MAAMC,WAAW,GAAIC,QAAgB,IAAK;EAC/C,IAAIA,QAAQ,CAACC,UAAU,CAAC,SAAS,CAAC,EAAE;IAClC,OAAQ,GAAEf,YAAa,SAAQc,QAAQ,CAACE,KAAK,CAAC,CAAC,CAAE,EAAC;EACpD;EAEA,OAAOF,QAAQ;AACjB,CAAC;AAED,OAAO,MAAMG,gBAAgB,GAAIC,IAAa,IAAK;EACjD,OAAOhB,UAAU,CAACD,UAAU,CAACiB,IAAI,CAAC,CAACP,OAAO,CAAC;AAC7C,CAAC;AAED,OAAO,MAAMQ,eAAe,GAAG,OAAOd,UAAkB,EAAEe,OAAe,KAAK;EAC5E,IAAI;IACF,MAAMC,QAAQ,GAAGlB,iBAAiB,CAACE,UAAU,CAAC;IAC9C,MAAMS,QAAQ,GAAG,MAAMO,QAAQ,CAACC,QAAQ,CAACF,OAAO,CAAC;IACjD,MAAMG,eAAe,GAAG,MAAMC,KAAK,CAACX,WAAW,CAACC,QAAQ,CAAC,CAAC;IAE1D,IAAI,CAACS,eAAe,CAACE,EAAE,EAAE;MACvB,OAAO,IAAI;IACb;IAEA,MAAMC,OAAO,GAAG,MAAMH,eAAe,CAACI,IAAI,EAAE;IAC5C,OAAOD,OAAO;EAChB,CAAC,CAAC,OAAOE,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,iBAAiB,EAAEA,KAAK,CAAC;IACvC,OAAO,IAAI;EACb;AACF,CAAC;AAED,OAAO,MAAME,eAAe,GAAG,OAAOzB,UAAkB,EAAEe,OAAe,KAA0B;EACjG,MAAMM,OAAO,GAAG,MAAMP,eAAe,CAACd,UAAU,EAAEe,OAAO,CAAC;EAC1D,MAAMR,aAAa,GAAGR,2BAA2B,CAACC,UAAU,CAAC;;EAE7D;EACA;EACA,IAAI,CAACqB,OAAO,EAAE;IACZ,OAAO,IAAI;EACb;EAEA,IAAI,CAACd,aAAa,EAAE;IAClB,OAAO,IAAI;EACb;EAEA,IAAI,CAACc,OAAO,CAACd,aAAa,CAAC,EAAE;IAC3B,OAAO,IAAI;EACb;EAEA,OAAOb,IAAI,CAACU,IAAI,CAAEsB,GAAG,IAAK;IACxB,OAAOL,OAAO,CAACd,aAAa,CAAC,CAACoB,QAAQ,CAACD,GAAG,CAACE,UAAU,CAAC;EACxD,CAAC,CAAC;AACJ,CAAC"},"metadata":{},"sourceType":"module"}