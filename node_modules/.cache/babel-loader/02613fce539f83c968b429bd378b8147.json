{"ast":null,"code":"import{ethers}from'ethers';import{getMulticallContract}from'utils/contractHelpers';const multicall=async(abi,calls)=>{// try {\nconst multi=getMulticallContract();const itf=new ethers.utils.Interface(abi);const calldata=calls.map(call=>[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)]);const{returnData}=await multi.aggregate(calldata);const res=returnData.map((call,i)=>itf.decodeFunctionResult(calls[i].name,call));return res;// } catch (error) {\n// throw new Error(error)\n// }\n};/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */export const multicallv2=async function(abi,calls){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{requireSuccess:true};const{requireSuccess}=options;const multi=getMulticallContract();const itf=new ethers.utils.Interface(abi);const calldata=calls.map(call=>[call.address.toLowerCase(),itf.encodeFunctionData(call.name,call.params)]);const returnData=await multi.tryAggregate(requireSuccess,calldata);const res=returnData.map((call,i)=>{const[result,data]=call;return result?itf.decodeFunctionResult(calls[i].name,data):null;});return res;};export default multicall;","map":{"version":3,"names":["ethers","getMulticallContract","multicall","abi","calls","multi","itf","utils","Interface","calldata","map","call","address","toLowerCase","encodeFunctionData","name","params","returnData","aggregate","res","i","decodeFunctionResult","multicallv2","options","arguments","length","undefined","requireSuccess","tryAggregate","result","data"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/utils/multicall.ts"],"sourcesContent":["import { ethers } from 'ethers'\nimport { getMulticallContract } from 'utils/contractHelpers'\nimport { MultiCallResponse } from './types'\n\nexport interface Call {\n  address: string // Address of the contract\n  name: string // Function name on the contract (example: balanceOf)\n  params?: any[] // Function params\n}\n\ninterface MulticallOptions {\n  requireSuccess?: boolean\n}\n\nconst multicall = async <T = any>(abi: any[], calls: Call[]): Promise<T> => {\n  // try {\n    const multi = getMulticallContract()\n    const itf = new ethers.utils.Interface(abi)\n\n    const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n    const { returnData } = await multi.aggregate(calldata)\n\n    const res = returnData.map((call, i) => itf.decodeFunctionResult(calls[i].name, call))\n\n    return res\n  // } catch (error) {\n    \n    // throw new Error(error)\n  // }\n}\n\n/**\n * Multicall V2 uses the new \"tryAggregate\" function. It is different in 2 ways\n *\n * 1. If \"requireSuccess\" is false multicall will not bail out if one of the calls fails\n * 2. The return inclues a boolean whether the call was successful e.g. [wasSuccessfull, callResult]\n */\nexport const multicallv2 = async <T = any>(\n  abi: any[],\n  calls: Call[],\n  options: MulticallOptions = { requireSuccess: true },\n): Promise<MultiCallResponse<T>> => {\n  const { requireSuccess } = options\n  const multi = getMulticallContract()\n  const itf = new ethers.utils.Interface(abi)\n\n  const calldata = calls.map((call) => [call.address.toLowerCase(), itf.encodeFunctionData(call.name, call.params)])\n  const returnData = await multi.tryAggregate(requireSuccess, calldata)\n  const res = returnData.map((call, i) => {\n    const [result, data] = call\n    return result ? itf.decodeFunctionResult(calls[i].name, data) : null\n  })\n\n  return res\n}\n\nexport default multicall\n"],"mappings":"AAAA,OAASA,MAAM,KAAQ,QAAQ,CAC/B,OAASC,oBAAoB,KAAQ,uBAAuB,CAa5D,KAAM,CAAAC,SAAS,CAAG,KAAAA,CAAgBC,GAAU,CAAEC,KAAa,GAAiB,CAC1E;AACE,KAAM,CAAAC,KAAK,CAAGJ,oBAAoB,CAAC,CAAC,CACpC,KAAM,CAAAK,GAAG,CAAG,GAAI,CAAAN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC,CAE3C,KAAM,CAAAM,QAAQ,CAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,EAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,CAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,CAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC,CAClH,KAAM,CAAEC,UAAW,CAAC,CAAG,KAAM,CAAAZ,KAAK,CAACa,SAAS,CAACT,QAAQ,CAAC,CAEtD,KAAM,CAAAU,GAAG,CAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,CAAES,CAAC,GAAKd,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,CAAEJ,IAAI,CAAC,CAAC,CAEtF,MAAO,CAAAQ,GAAG,CACZ;AAEE;AACF;AACF,CAAC,CAED;AACA;AACA;AACA;AACA;AACA,GACA,MAAO,MAAM,CAAAG,WAAW,CAAG,cAAAA,CACzBnB,GAAU,CACVC,KAAa,CAEqB,IADlC,CAAAmB,OAAyB,CAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAG,CAAEG,cAAc,CAAE,IAAK,CAAC,CAEpD,KAAM,CAAEA,cAAe,CAAC,CAAGJ,OAAO,CAClC,KAAM,CAAAlB,KAAK,CAAGJ,oBAAoB,CAAC,CAAC,CACpC,KAAM,CAAAK,GAAG,CAAG,GAAI,CAAAN,MAAM,CAACO,KAAK,CAACC,SAAS,CAACL,GAAG,CAAC,CAE3C,KAAM,CAAAM,QAAQ,CAAGL,KAAK,CAACM,GAAG,CAAEC,IAAI,EAAK,CAACA,IAAI,CAACC,OAAO,CAACC,WAAW,CAAC,CAAC,CAAEP,GAAG,CAACQ,kBAAkB,CAACH,IAAI,CAACI,IAAI,CAAEJ,IAAI,CAACK,MAAM,CAAC,CAAC,CAAC,CAClH,KAAM,CAAAC,UAAU,CAAG,KAAM,CAAAZ,KAAK,CAACuB,YAAY,CAACD,cAAc,CAAElB,QAAQ,CAAC,CACrE,KAAM,CAAAU,GAAG,CAAGF,UAAU,CAACP,GAAG,CAAC,CAACC,IAAI,CAAES,CAAC,GAAK,CACtC,KAAM,CAACS,MAAM,CAAEC,IAAI,CAAC,CAAGnB,IAAI,CAC3B,MAAO,CAAAkB,MAAM,CAAGvB,GAAG,CAACe,oBAAoB,CAACjB,KAAK,CAACgB,CAAC,CAAC,CAACL,IAAI,CAAEe,IAAI,CAAC,CAAG,IAAI,CACtE,CAAC,CAAC,CAEF,MAAO,CAAAX,GAAG,CACZ,CAAC,CAED,cAAe,CAAAjB,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module"}