{"ast":null,"code":"/* eslint-disable no-continue */\n/* eslint-disable lines-between-class-members */\n/* eslint-disable consistent-return */\n/* eslint-disable no-lonely-if */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\n\nimport { ONE, TradeType, ZERO } from '../constants';\nimport { sortedInsert } from '../utils';\nimport { ETHER } from './currency';\nimport { CurrencyAmount } from './fractions/currencyAmount';\nimport { Fraction } from './fractions/fraction';\nimport { Percent } from './fractions/percent';\nimport { Price } from './fractions/price';\nimport { TokenAmount } from './fractions/tokenAmount';\nimport { Route } from './route';\nimport { Token, WETH } from './token';\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice, inputAmount, outputAmount) {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw);\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);\n  return new Percent(slippage.numerator, slippage.denominator);\n}\n\n// minimal interface so the input output comparator may be shared across types\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a, b) {\n  // must have same input and output token for comparison\n  // invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  // invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0;\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a, b) {\n  const ioComp = inputOutputComparator(a, b);\n  if (ioComp !== 0) {\n    return ioComp;\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1;\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1;\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length;\n}\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount, chainId) {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount;\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw);\n  // invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency, chainId) {\n  if (currency instanceof Token) return currency;\n  if (currency === ETHER) return WETH[chainId];\n  // invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  static exactIn(route, amountIn) {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT);\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  static exactOut(route, amountOut) {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\n  }\n  constructor(route, amount, tradeType) {\n    this.route = void 0;\n    this.tradeType = void 0;\n    this.inputAmount = void 0;\n    this.outputAmount = void 0;\n    this.executionPrice = void 0;\n    this.nextMidPrice = void 0;\n    this.priceImpact = void 0;\n    const amounts = new Array(route.path.length);\n    const nextPairs = new Array(route.pairs.length);\n    if (tradeType === TradeType.EXACT_INPUT) {\n      // invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId);\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i];\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i]);\n        amounts[i + 1] = outputAmount;\n        nextPairs[i] = nextPair;\n      }\n    } else {\n      // invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId);\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1];\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i]);\n        amounts[i - 1] = inputAmount;\n        nextPairs[i - 1] = nextPair;\n      }\n    }\n    this.route = route;\n    this.tradeType = tradeType;\n    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : route.input === ETHER ? CurrencyAmount.ether(amounts[0].raw) : amounts[0];\n    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : route.output === ETHER ? CurrencyAmount.ether(amounts[amounts.length - 1].raw) : amounts[amounts.length - 1];\n    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  minimumAmountOut(slippageTolerance) {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount;\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;\n      return this.outputAmount instanceof TokenAmount ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut) : CurrencyAmount.ether(slippageAdjustedAmountOut);\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  maximumAmountIn(slippageTolerance) {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount;\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;\n      return this.inputAmount instanceof TokenAmount ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn) : CurrencyAmount.ether(slippageAdjustedAmountIn);\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  static bestTradeExactIn(pairs, currencyAmountIn, currencyOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let originalAmountIn = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountIn;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : undefined;\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId);\n    const tokenOut = wrappedCurrency(currencyOut, chainId);\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      let amountOut;\n      try {\n        [amountOut] = pair.getOutputAmount(amountIn);\n      } catch (error) {\n        // input too low\n        if (1) {\n          continue;\n        }\n        throw error;\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [...currentPairs, pair], originalAmountIn, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  static bestTradeExactOut(pairs, currencyIn, currencyAmountOut) {\n    let {\n      maxNumResults = 3,\n      maxHops = 3\n    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let currentPairs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let originalAmountOut = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : currencyAmountOut;\n    let bestTrades = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : undefined;\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId);\n    const tokenIn = wrappedCurrency(currencyIn, chainId);\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i];\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue;\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue;\n      let amountIn;\n      try {\n        [amountIn] = pair.getInputAmount(amountOut);\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (1) {\n          continue;\n        }\n        throw error;\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {\n          maxNumResults,\n          maxHops: maxHops - 1\n        }, [pair, ...currentPairs], originalAmountOut, bestTrades);\n      }\n    }\n    return bestTrades;\n  }\n}","map":{"version":3,"names":["ONE","TradeType","ZERO","sortedInsert","ETHER","CurrencyAmount","Fraction","Percent","Price","TokenAmount","Route","Token","WETH","computePriceImpact","midPrice","inputAmount","outputAmount","exactQuote","raw","multiply","slippage","subtract","divide","numerator","denominator","inputOutputComparator","a","b","equalTo","lessThan","tradeComparator","ioComp","priceImpact","greaterThan","route","path","length","wrappedAmount","currencyAmount","chainId","currency","wrappedCurrency","Trade","exactIn","amountIn","EXACT_INPUT","exactOut","amountOut","EXACT_OUTPUT","constructor","amount","tradeType","executionPrice","nextMidPrice","amounts","Array","nextPairs","pairs","i","pair","nextPair","getOutputAmount","getInputAmount","input","ether","output","fromRoute","minimumAmountOut","slippageTolerance","slippageAdjustedAmountOut","add","invert","quotient","token","maximumAmountIn","slippageAdjustedAmountIn","bestTradeExactIn","currencyAmountIn","currencyOut","maxNumResults","maxHops","currentPairs","originalAmountIn","bestTrades","undefined","tokenOut","token0","equals","token1","reserve0","reserve1","error","pairsExcludingThisPair","slice","concat","bestTradeExactOut","currencyIn","currencyAmountOut","originalAmountOut","tokenIn"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/sdk/entities/trade.ts"],"sourcesContent":["/* eslint-disable no-continue */\n/* eslint-disable lines-between-class-members */\n/* eslint-disable consistent-return */\n/* eslint-disable no-lonely-if */\n/* eslint-disable no-else-return */\n// import invariant from 'tiny-invariant'\n\nimport { ChainId, ONE, TradeType, ZERO } from '../constants'\nimport { sortedInsert } from '../utils'\nimport { Currency, ETHER } from './currency'\nimport { CurrencyAmount } from './fractions/currencyAmount'\nimport { Fraction } from './fractions/fraction'\nimport { Percent } from './fractions/percent'\nimport { Price } from './fractions/price'\nimport { TokenAmount } from './fractions/tokenAmount'\nimport { Pair } from './pair'\nimport { Route } from './route'\nimport { currencyEquals, Token, WETH } from './token'\n\n/**\n * Returns the percent difference between the mid price and the execution price, i.e. price impact.\n * @param midPrice mid price before the trade\n * @param inputAmount the input amount of the trade\n * @param outputAmount the output amount of the trade\n */\nfunction computePriceImpact(midPrice: Price, inputAmount: CurrencyAmount, outputAmount: CurrencyAmount): Percent {\n  const exactQuote = midPrice.raw.multiply(inputAmount.raw)\n  // calculate slippage := (exactQuote - outputAmount) / exactQuote\n  const slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote)\n  return new Percent(slippage.numerator, slippage.denominator)\n}\n\n// minimal interface so the input output comparator may be shared across types\ninterface InputOutput {\n  readonly inputAmount: CurrencyAmount\n  readonly outputAmount: CurrencyAmount\n}\n\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\nexport function inputOutputComparator(a: InputOutput, b: InputOutput): number {\n  // must have same input and output token for comparison\n  // invariant(currencyEquals(a.inputAmount.currency, b.inputAmount.currency), 'INPUT_CURRENCY')\n  // invariant(currencyEquals(a.outputAmount.currency, b.outputAmount.currency), 'OUTPUT_CURRENCY')\n  if (a.outputAmount.equalTo(b.outputAmount)) {\n    if (a.inputAmount.equalTo(b.inputAmount)) {\n      return 0\n    }\n    // trade A requires less input than trade B, so A should come first\n    if (a.inputAmount.lessThan(b.inputAmount)) {\n      return -1\n    } else {\n      return 1\n    }\n  } else {\n    // tradeA has less output than trade B, so should come second\n    if (a.outputAmount.lessThan(b.outputAmount)) {\n      return 1\n    } else {\n      return -1\n    }\n  }\n}\n\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\nexport function tradeComparator(a: Trade, b: Trade) {\n  const ioComp = inputOutputComparator(a, b)\n  if (ioComp !== 0) {\n    return ioComp\n  }\n\n  // consider lowest slippage next, since these are less likely to fail\n  if (a.priceImpact.lessThan(b.priceImpact)) {\n    return -1\n  } else if (a.priceImpact.greaterThan(b.priceImpact)) {\n    return 1\n  }\n\n  // finally consider the number of hops since each hop costs gas\n  return a.route.path.length - b.route.path.length\n}\n\nexport interface BestTradeOptions {\n  // how many results to return\n  maxNumResults?: number\n  // the maximum number of hops a trade should contain\n  maxHops?: number\n}\n\n/**\n * Given a currency amount and a chain ID, returns the equivalent representation as the token amount.\n * In other words, if the currency is ETHER, returns the WETH token amount for the given chain. Otherwise, returns\n * the input currency amount.\n */\nfunction wrappedAmount(currencyAmount: CurrencyAmount, chainId: ChainId): TokenAmount {\n  if (currencyAmount instanceof TokenAmount) return currencyAmount\n  if (currencyAmount.currency === ETHER) return new TokenAmount(WETH[chainId], currencyAmount.raw)\n  // invariant(false, 'CURRENCY')\n}\n\nfunction wrappedCurrency(currency: Currency, chainId: ChainId): Token {\n  if (currency instanceof Token) return currency\n  if (currency === ETHER) return WETH[chainId]\n  // invariant(false, 'CURRENCY')\n}\n\n/**\n * Represents a trade executed against a list of pairs.\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\n */\nexport class Trade {\n  /**\n   * The route of the trade, i.e. which pairs the trade goes through.\n   */\n  public readonly route: Route\n  /**\n   * The type of the trade, either exact in or exact out.\n   */\n  public readonly tradeType: TradeType\n  /**\n   * The input amount for the trade assuming no slippage.\n   */\n  public readonly inputAmount: CurrencyAmount\n  /**\n   * The output amount for the trade assuming no slippage.\n   */\n  public readonly outputAmount: CurrencyAmount\n  /**\n   * The price expressed in terms of output amount/input amount.\n   */\n  public readonly executionPrice: Price\n  /**\n   * The mid price after the trade executes assuming no slippage.\n   */\n  public readonly nextMidPrice: Price\n  /**\n   * The percent difference between the mid price before the trade and the trade execution price.\n   */\n  public readonly priceImpact: Percent\n\n  /**\n   * Constructs an exact in trade with the given amount in and route\n   * @param route route of the exact in trade\n   * @param amountIn the amount being passed in\n   */\n  public static exactIn(route: Route, amountIn: CurrencyAmount): Trade {\n    return new Trade(route, amountIn, TradeType.EXACT_INPUT)\n  }\n\n  /**\n   * Constructs an exact out trade with the given amount out and route\n   * @param route route of the exact out trade\n   * @param amountOut the amount returned by the trade\n   */\n  public static exactOut(route: Route, amountOut: CurrencyAmount): Trade {\n    return new Trade(route, amountOut, TradeType.EXACT_OUTPUT)\n  }\n\n  public constructor(route: Route, amount: CurrencyAmount, tradeType: TradeType) {\n    const amounts: TokenAmount[] = new Array(route.path.length)\n    const nextPairs: Pair[] = new Array(route.pairs.length)\n    if (tradeType === TradeType.EXACT_INPUT) {\n      // invariant(currencyEquals(amount.currency, route.input), 'INPUT')\n      amounts[0] = wrappedAmount(amount, route.chainId)\n      for (let i = 0; i < route.path.length - 1; i++) {\n        const pair = route.pairs[i]\n        const [outputAmount, nextPair] = pair.getOutputAmount(amounts[i])\n        amounts[i + 1] = outputAmount\n        nextPairs[i] = nextPair\n      }\n    } else {\n      // invariant(currencyEquals(amount.currency, route.output), 'OUTPUT')\n      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId)\n      for (let i = route.path.length - 1; i > 0; i--) {\n        const pair = route.pairs[i - 1]\n        const [inputAmount, nextPair] = pair.getInputAmount(amounts[i])\n        amounts[i - 1] = inputAmount\n        nextPairs[i - 1] = nextPair\n      }\n    }\n\n    this.route = route\n    this.tradeType = tradeType\n    this.inputAmount =\n      tradeType === TradeType.EXACT_INPUT\n        ? amount\n        : route.input === ETHER\n        ? CurrencyAmount.ether(amounts[0].raw)\n        : amounts[0]\n    this.outputAmount =\n      tradeType === TradeType.EXACT_OUTPUT\n        ? amount\n        : route.output === ETHER\n        ? CurrencyAmount.ether(amounts[amounts.length - 1].raw)\n        : amounts[amounts.length - 1]\n    this.executionPrice = new Price(\n      this.inputAmount.currency,\n      this.outputAmount.currency,\n      this.inputAmount.raw,\n      this.outputAmount.raw\n    )\n    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input))\n    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount)\n  }\n\n  /**\n   * Get the minimum amount that must be received from this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public minimumAmountOut(slippageTolerance: Percent): CurrencyAmount {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_OUTPUT) {\n      return this.outputAmount\n    } else {\n      const slippageAdjustedAmountOut = new Fraction(ONE)\n        .add(slippageTolerance)\n        .invert()\n        .multiply(this.outputAmount.raw).quotient\n      return this.outputAmount instanceof TokenAmount\n        ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut)\n        : CurrencyAmount.ether(slippageAdjustedAmountOut)\n    }\n  }\n\n  /**\n   * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\n   * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\n   */\n  public maximumAmountIn(slippageTolerance: Percent): CurrencyAmount {\n    // invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE')\n    if (this.tradeType === TradeType.EXACT_INPUT) {\n      return this.inputAmount\n    } else {\n      const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient\n      return this.inputAmount instanceof TokenAmount\n        ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn)\n        : CurrencyAmount.ether(slippageAdjustedAmountIn)\n    }\n  }\n\n  /**\n   * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\n   * amount to an output token, making at most `maxHops` hops.\n   * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyAmountIn exact amount of input currency to spend\n   * @param currencyOut the desired currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountIn used in recursion; the original value of the currencyAmountIn parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactIn(\n    pairs: Pair[],\n    currencyAmountIn: CurrencyAmount,\n    currencyOut: Currency,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountIn: CurrencyAmount = currencyAmountIn,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountIn === currencyAmountIn || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountIn instanceof TokenAmount\n        ? currencyAmountIn.token.chainId\n        : currencyOut instanceof Token\n        ? currencyOut.chainId\n        : undefined\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountIn = wrappedAmount(currencyAmountIn, chainId)\n    const tokenOut = wrappedCurrency(currencyOut, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountOut: TokenAmount\n      try {\n        [amountOut] = pair.getOutputAmount(amountIn)\n      } catch (error) {\n        // input too low\n        if (1) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the output token, so this is the final trade of one of the paths\n      if (amountOut.token.equals(tokenOut)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([...currentPairs, pair], originalAmountIn.currency, currencyOut),\n            originalAmountIn,\n            TradeType.EXACT_INPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactIn(\n          pairsExcludingThisPair,\n          amountOut,\n          currencyOut,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [...currentPairs, pair],\n          originalAmountIn,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n\n  /**\n   * similar to the above method but instead targets a fixed output amount\n   * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\n   * to an output token amount, making at most `maxHops` hops\n   * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\n   * the amount in among multiple routes.\n   * @param pairs the pairs to consider in finding the best trade\n   * @param currencyIn the currency to spend\n   * @param currencyAmountOut the exact amount of currency out\n   * @param maxNumResults maximum number of results to return\n   * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\n   * @param currentPairs used in recursion; the current list of pairs\n   * @param originalAmountOut used in recursion; the original value of the currencyAmountOut parameter\n   * @param bestTrades used in recursion; the current list of best trades\n   */\n  public static bestTradeExactOut(\n    pairs: Pair[],\n    currencyIn: Currency,\n    currencyAmountOut: CurrencyAmount,\n    { maxNumResults = 3, maxHops = 3 }: BestTradeOptions = {},\n    // used in recursion.\n    currentPairs: Pair[] = [],\n    originalAmountOut: CurrencyAmount = currencyAmountOut,\n    bestTrades: Trade[] = []\n  ): Trade[] {\n    // invariant(pairs.length > 0, 'PAIRS')\n    // invariant(maxHops > 0, 'MAX_HOPS')\n    // invariant(originalAmountOut === currencyAmountOut || currentPairs.length > 0, 'INVALID_RECURSION')\n    const chainId: ChainId | undefined =\n      currencyAmountOut instanceof TokenAmount\n        ? currencyAmountOut.token.chainId\n        : currencyIn instanceof Token\n        ? currencyIn.chainId\n        : undefined\n    // invariant(chainId !== undefined, 'CHAIN_ID')\n\n    const amountOut = wrappedAmount(currencyAmountOut, chainId)\n    const tokenIn = wrappedCurrency(currencyIn, chainId)\n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i]\n      // pair irrelevant\n      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token)) continue\n      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO)) continue\n\n      let amountIn: TokenAmount\n      try {\n        [amountIn] = pair.getInputAmount(amountOut)\n      } catch (error) {\n        // not enough liquidity in this pair\n        if (1) {\n          continue\n        }\n        throw error\n      }\n      // we have arrived at the input token, so this is the first trade of one of the paths\n      if (amountIn.token.equals(tokenIn)) {\n        sortedInsert(\n          bestTrades,\n          new Trade(\n            new Route([pair, ...currentPairs], currencyIn, originalAmountOut.currency),\n            originalAmountOut,\n            TradeType.EXACT_OUTPUT\n          ),\n          maxNumResults,\n          tradeComparator\n        )\n      } else if (maxHops > 1 && pairs.length > 1) {\n        const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length))\n\n        // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\n        Trade.bestTradeExactOut(\n          pairsExcludingThisPair,\n          currencyIn,\n          amountIn,\n          {\n            maxNumResults,\n            maxHops: maxHops - 1\n          },\n          [pair, ...currentPairs],\n          originalAmountOut,\n          bestTrades\n        )\n      }\n    }\n\n    return bestTrades\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}