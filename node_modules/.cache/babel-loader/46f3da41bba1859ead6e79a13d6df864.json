{"ast":null,"code":"import _taggedTemplateLiteral from\"/Users/namratapatel/upwork/SmartFinance-OmniDex/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\";var _templateObject;import{request,gql}from'graphql-request';import{GRAPH_API_LOTTERY}from'config/constants/endpoints';import{getRoundIdsArray,fetchMultipleLotteries}from'./helpers';const applyNodeDataToLotteriesGraphResponse=(nodeData,graphResponse)=>{//   If no graph response - return node data\nif(graphResponse.length===0){return nodeData.map(nodeRound=>{return{endTime:nodeRound.endTime,finalNumber:nodeRound.finalNumber.toString(),startTime:nodeRound.startTime,status:nodeRound.status,id:nodeRound.lotteryId.toString(),ticketPrice:nodeRound.priceTicketInCake,totalTickets:'',totalUsers:'',winningTickets:''};});}//   Else if there is a graph response - merge with node data where node data is more reliable\nconst mergedResponse=graphResponse.map((graphRound,index)=>{const nodeRound=nodeData[index];// if there is node data for this index, overwrite graph data. Otherwise - return graph data.\nif(nodeRound){// if isLoading === true, there has been a node error - return graphRound\nif(!nodeRound.isLoading){return{endTime:nodeRound.endTime,finalNumber:nodeRound.finalNumber.toString(),startTime:nodeRound.startTime,status:nodeRound.status,id:graphRound.id,ticketPrice:graphRound.ticketPrice,totalTickets:graphRound.totalTickets,totalUsers:graphRound.totalUsers,winningTickets:graphRound.winningTickets};}return graphRound;}return graphRound;});return mergedResponse;};const getGraphLotteries=async()=>{try{const response=await request(GRAPH_API_LOTTERY,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n        query getLotteries {\\n          lotteries(first: 100, orderDirection: desc, orderBy: block) {\\n            id\\n            totalUsers\\n            totalTickets\\n            winningTickets\\n            status\\n            finalNumber\\n            startTime\\n            endTime\\n            ticketPrice\\n          }\\n        }\\n      \"]))));return response.lotteries;}catch(error){console.error(error);return[];}};const getLotteriesData=async currentLotteryId=>{const idsForNodesCall=getRoundIdsArray(currentLotteryId);const nodeData=await fetchMultipleLotteries(idsForNodesCall);const graphResponse=await getGraphLotteries();const mergedData=applyNodeDataToLotteriesGraphResponse(nodeData,graphResponse);return mergedData;};export default getLotteriesData;","map":{"version":3,"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","applyNodeDataToLotteriesGraphResponse","nodeData","graphResponse","length","map","nodeRound","endTime","finalNumber","toString","startTime","status","id","lotteryId","ticketPrice","priceTicketInCake","totalTickets","totalUsers","winningTickets","mergedResponse","graphRound","index","isLoading","getGraphLotteries","response","_templateObject","_taggedTemplateLiteral","lotteries","error","console","getLotteriesData","currentLotteryId","idsForNodesCall","mergedData"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/state/lottery/getLotteriesData.ts"],"sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryRoundGraphEntity, LotteryResponse } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers'\n\nconst applyNodeDataToLotteriesGraphResponse = (\n  nodeData: LotteryResponse[],\n  graphResponse: LotteryRoundGraphEntity[],\n): LotteryRoundGraphEntity[] => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map((nodeRound) => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: '',\n      }\n    })\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more reliable\n  const mergedResponse = graphResponse.map((graphRound, index) => {\n    const nodeRound = nodeData[index]\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          finalNumber: nodeRound.finalNumber.toString(),\n          startTime: nodeRound.startTime,\n          status: nodeRound.status,\n          id: graphRound.id,\n          ticketPrice: graphRound.ticketPrice,\n          totalTickets: graphRound.totalTickets,\n          totalUsers: graphRound.totalUsers,\n          winningTickets: graphRound.winningTickets,\n        }\n      }\n      return graphRound\n    }\n    return graphRound\n  })\n  return mergedResponse\n}\n\nconst getGraphLotteries = async (): Promise<LotteryRoundGraphEntity[]> => {\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getLotteries {\n          lotteries(first: 100, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `,\n    )\n    return response.lotteries\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst getLotteriesData = async (currentLotteryId: string): Promise<LotteryRoundGraphEntity[]> => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId)\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall)\n  const graphResponse = await getGraphLotteries()\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse)\n  return mergedData\n}\n\nexport default getLotteriesData\n"],"mappings":"yKAAA,OAASA,OAAO,CAAEC,GAAG,KAAQ,iBAAiB,CAC9C,OAASC,iBAAiB,KAAQ,4BAA4B,CAE9D,OAASC,gBAAgB,CAAEC,sBAAsB,KAAQ,WAAW,CAEpE,KAAM,CAAAC,qCAAqC,CAAGA,CAC5CC,QAA2B,CAC3BC,aAAwC,GACV,CAC9B;AACA,GAAIA,aAAa,CAACC,MAAM,GAAK,CAAC,CAAE,CAC9B,MAAO,CAAAF,QAAQ,CAACG,GAAG,CAAEC,SAAS,EAAK,CACjC,MAAO,CACLC,OAAO,CAAED,SAAS,CAACC,OAAO,CAC1BC,WAAW,CAAEF,SAAS,CAACE,WAAW,CAACC,QAAQ,CAAC,CAAC,CAC7CC,SAAS,CAAEJ,SAAS,CAACI,SAAS,CAC9BC,MAAM,CAAEL,SAAS,CAACK,MAAM,CACxBC,EAAE,CAAEN,SAAS,CAACO,SAAS,CAACJ,QAAQ,CAAC,CAAC,CAClCK,WAAW,CAAER,SAAS,CAACS,iBAAiB,CACxCC,YAAY,CAAE,EAAE,CAChBC,UAAU,CAAE,EAAE,CACdC,cAAc,CAAE,EAClB,CAAC,CACH,CAAC,CAAC,CACJ,CAEA;AACA,KAAM,CAAAC,cAAc,CAAGhB,aAAa,CAACE,GAAG,CAAC,CAACe,UAAU,CAAEC,KAAK,GAAK,CAC9D,KAAM,CAAAf,SAAS,CAAGJ,QAAQ,CAACmB,KAAK,CAAC,CACjC;AACA,GAAIf,SAAS,CAAE,CACb;AACA,GAAI,CAACA,SAAS,CAACgB,SAAS,CAAE,CACxB,MAAO,CACLf,OAAO,CAAED,SAAS,CAACC,OAAO,CAC1BC,WAAW,CAAEF,SAAS,CAACE,WAAW,CAACC,QAAQ,CAAC,CAAC,CAC7CC,SAAS,CAAEJ,SAAS,CAACI,SAAS,CAC9BC,MAAM,CAAEL,SAAS,CAACK,MAAM,CACxBC,EAAE,CAAEQ,UAAU,CAACR,EAAE,CACjBE,WAAW,CAAEM,UAAU,CAACN,WAAW,CACnCE,YAAY,CAAEI,UAAU,CAACJ,YAAY,CACrCC,UAAU,CAAEG,UAAU,CAACH,UAAU,CACjCC,cAAc,CAAEE,UAAU,CAACF,cAC7B,CAAC,CACH,CACA,MAAO,CAAAE,UAAU,CACnB,CACA,MAAO,CAAAA,UAAU,CACnB,CAAC,CAAC,CACF,MAAO,CAAAD,cAAc,CACvB,CAAC,CAED,KAAM,CAAAI,iBAAiB,CAAG,KAAAA,CAAA,GAAgD,CACxE,GAAI,CACF,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAA5B,OAAO,CAC5BE,iBAAiB,CACjBD,GAAG,CAAA4B,eAAA,GAAAA,eAAA,CAAAC,sBAAA,+VAeL,CAAC,CACD,MAAO,CAAAF,QAAQ,CAACG,SAAS,CAC3B,CAAE,MAAOC,KAAK,CAAE,CACdC,OAAO,CAACD,KAAK,CAACA,KAAK,CAAC,CACpB,MAAO,EAAE,CACX,CACF,CAAC,CAED,KAAM,CAAAE,gBAAgB,CAAG,KAAO,CAAAC,gBAAwB,EAAyC,CAC/F,KAAM,CAAAC,eAAe,CAAGjC,gBAAgB,CAACgC,gBAAgB,CAAC,CAC1D,KAAM,CAAA7B,QAAQ,CAAG,KAAM,CAAAF,sBAAsB,CAACgC,eAAe,CAAC,CAC9D,KAAM,CAAA7B,aAAa,CAAG,KAAM,CAAAoB,iBAAiB,CAAC,CAAC,CAC/C,KAAM,CAAAU,UAAU,CAAGhC,qCAAqC,CAACC,QAAQ,CAAEC,aAAa,CAAC,CACjF,MAAO,CAAA8B,UAAU,CACnB,CAAC,CAED,cAAe,CAAAH,gBAAgB","ignoreList":[]},"metadata":{},"sourceType":"module"}