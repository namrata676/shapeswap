{"ast":null,"code":"import { useCallback, useContext, useEffect } from \"react\";\nimport get from \"lodash/get\";\nimport { Context } from \"./ModalContext\";\nconst useModal = (modal, closeOnOverlayClick = true, updateOnPropsChange = false, modalId = \"defaultNodeId\") => {\n  const {\n    isOpen,\n    nodeId,\n    modalNode,\n    setModalNode,\n    onPresent,\n    onDismiss,\n    setCloseOnOverlayClick\n  } = useContext(Context);\n  const onPresentCallback = useCallback(() => {\n    onPresent(modal, modalId);\n  }, [modal, modalId, onPresent]);\n\n  // Updates the \"modal\" component if props are changed\n  // Use carefully since it might result in unnecessary rerenders\n  // Typically if modal is staic there is no need for updates, use when you expect props to change\n  useEffect(() => {\n    // NodeId is needed in case there are 2 useModal hooks on the same page and one has updateOnPropsChange\n    if (updateOnPropsChange && isOpen && nodeId === modalId) {\n      const modalProps = get(modal, \"props\");\n      const oldModalProps = get(modalNode, \"props\");\n      // Note: I tried to use lodash isEqual to compare props but it is giving false-negatives too easily\n      // For example ConfirmSwapModal in exchange has ~500 lines prop object that stringifies to same string\n      // and online diff checker says both objects are identical but lodash isEqual thinks they are different\n      // Do not try to replace JSON.stringify with isEqual, high risk of infinite rerenders\n      // TODO: Find a good way to handle modal updates, this whole flow is just backwards-compatible workaround,\n      // would be great to simplify the logic here\n      if (modalProps && oldModalProps && JSON.stringify(modalProps) !== JSON.stringify(oldModalProps)) {\n        setModalNode(modal);\n      }\n    }\n  }, [updateOnPropsChange, nodeId, modalId, isOpen, modal, modalNode, setModalNode]);\n  useEffect(() => {\n    setCloseOnOverlayClick(closeOnOverlayClick);\n  }, [closeOnOverlayClick, setCloseOnOverlayClick]);\n  return [onPresentCallback, onDismiss];\n};\nexport default useModal;","map":{"version":3,"names":["useCallback","useContext","useEffect","get","Context","useModal","modal","closeOnOverlayClick","updateOnPropsChange","modalId","isOpen","nodeId","modalNode","setModalNode","onPresent","onDismiss","setCloseOnOverlayClick","onPresentCallback","modalProps","oldModalProps","JSON","stringify"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/toolkit/uikit/widgets/SlippageModal/useModal.ts"],"sourcesContent":["import React, { useCallback, useContext, useEffect } from \"react\";\nimport get from \"lodash/get\";\nimport { Context } from \"./ModalContext\";\nimport { Handler } from \"./types\";\n\nconst useModal = (\n  modal: React.ReactNode,\n  closeOnOverlayClick = true,\n  updateOnPropsChange = false,\n  modalId = \"defaultNodeId\"\n): [Handler, Handler] => {\n  const { isOpen, nodeId, modalNode, setModalNode, onPresent, onDismiss, setCloseOnOverlayClick } = useContext(Context);\n  const onPresentCallback = useCallback(() => {\n    onPresent(modal, modalId);\n  }, [modal, modalId, onPresent]);\n\n  // Updates the \"modal\" component if props are changed\n  // Use carefully since it might result in unnecessary rerenders\n  // Typically if modal is staic there is no need for updates, use when you expect props to change\n  useEffect(() => {\n    // NodeId is needed in case there are 2 useModal hooks on the same page and one has updateOnPropsChange\n    if (updateOnPropsChange && isOpen && nodeId === modalId) {\n      const modalProps = get(modal, \"props\");\n      const oldModalProps = get(modalNode, \"props\");\n      // Note: I tried to use lodash isEqual to compare props but it is giving false-negatives too easily\n      // For example ConfirmSwapModal in exchange has ~500 lines prop object that stringifies to same string\n      // and online diff checker says both objects are identical but lodash isEqual thinks they are different\n      // Do not try to replace JSON.stringify with isEqual, high risk of infinite rerenders\n      // TODO: Find a good way to handle modal updates, this whole flow is just backwards-compatible workaround,\n      // would be great to simplify the logic here\n      if (modalProps && oldModalProps && JSON.stringify(modalProps) !== JSON.stringify(oldModalProps)) {\n        setModalNode(modal);\n      }\n    }\n  }, [updateOnPropsChange, nodeId, modalId, isOpen, modal, modalNode, setModalNode]);\n\n  useEffect(() => {\n    setCloseOnOverlayClick(closeOnOverlayClick);\n  }, [closeOnOverlayClick, setCloseOnOverlayClick]);\n\n  return [onPresentCallback, onDismiss];\n};\n\nexport default useModal;\n"],"mappings":"AAAA,SAAgBA,WAAW,EAAEC,UAAU,EAAEC,SAAS,QAAQ,OAAO;AACjE,OAAOC,GAAG,MAAM,YAAY;AAC5B,SAASC,OAAO,QAAQ,gBAAgB;AAGxC,MAAMC,QAAQ,GAAGA,CACfC,KAAsB,EACtBC,mBAAmB,GAAG,IAAI,EAC1BC,mBAAmB,GAAG,KAAK,EAC3BC,OAAO,GAAG,eAAe,KACF;EACvB,MAAM;IAAEC,MAAM;IAAEC,MAAM;IAAEC,SAAS;IAAEC,YAAY;IAAEC,SAAS;IAAEC,SAAS;IAAEC;EAAuB,CAAC,GAAGf,UAAU,CAACG,OAAO,CAAC;EACrH,MAAMa,iBAAiB,GAAGjB,WAAW,CAAC,MAAM;IAC1Cc,SAAS,CAACR,KAAK,EAAEG,OAAO,CAAC;EAC3B,CAAC,EAAE,CAACH,KAAK,EAAEG,OAAO,EAAEK,SAAS,CAAC,CAAC;;EAE/B;EACA;EACA;EACAZ,SAAS,CAAC,MAAM;IACd;IACA,IAAIM,mBAAmB,IAAIE,MAAM,IAAIC,MAAM,KAAKF,OAAO,EAAE;MACvD,MAAMS,UAAU,GAAGf,GAAG,CAACG,KAAK,EAAE,OAAO,CAAC;MACtC,MAAMa,aAAa,GAAGhB,GAAG,CAACS,SAAS,EAAE,OAAO,CAAC;MAC7C;MACA;MACA;MACA;MACA;MACA;MACA,IAAIM,UAAU,IAAIC,aAAa,IAAIC,IAAI,CAACC,SAAS,CAACH,UAAU,CAAC,KAAKE,IAAI,CAACC,SAAS,CAACF,aAAa,CAAC,EAAE;QAC/FN,YAAY,CAACP,KAAK,CAAC;MACrB;IACF;EACF,CAAC,EAAE,CAACE,mBAAmB,EAAEG,MAAM,EAAEF,OAAO,EAAEC,MAAM,EAAEJ,KAAK,EAAEM,SAAS,EAAEC,YAAY,CAAC,CAAC;EAElFX,SAAS,CAAC,MAAM;IACdc,sBAAsB,CAACT,mBAAmB,CAAC;EAC7C,CAAC,EAAE,CAACA,mBAAmB,EAAES,sBAAsB,CAAC,CAAC;EAEjD,OAAO,CAACC,iBAAiB,EAAEF,SAAS,CAAC;AACvC,CAAC;AAED,eAAeV,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module"}