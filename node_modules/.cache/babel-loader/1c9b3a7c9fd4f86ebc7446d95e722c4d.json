{"ast":null,"code":"import { useEffect, useMemo } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport useActiveWeb3React from 'hooks/useActiveWeb3React';\nimport { useBlockNumber } from '../application/hooks';\nimport { addMulticallListeners, removeMulticallListeners, parseCallKey, toCallKey } from './actions';\nfunction isMethodArg(x) {\n  return ['string', 'number'].indexOf(typeof x) !== -1;\n}\nfunction isValidMethodArgs(x) {\n  return x === undefined || Array.isArray(x) && x.every(xi => isMethodArg(xi) || Array.isArray(xi) && xi.every(isMethodArg));\n}\nconst INVALID_RESULT = {\n  valid: false,\n  blockNumber: undefined,\n  data: undefined\n};\n\n// use this options object\nexport const NEVER_RELOAD = {\n  blocksPerFetch: Infinity\n};\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls, options) {\n  const {\n    chainId\n  } = useActiveWeb3React();\n  const callResults = useSelector(state => state.multicall.callResults);\n  const dispatch = useDispatch();\n  const serializedCallKeys = useMemo(() => {\n    var _calls$filter$map$sor, _calls$filter, _calls$filter$map;\n    return JSON.stringify((_calls$filter$map$sor = calls === null || calls === void 0 ? void 0 : (_calls$filter = calls.filter(c => Boolean(c))) === null || _calls$filter === void 0 ? void 0 : (_calls$filter$map = _calls$filter.map(toCallKey)) === null || _calls$filter$map === void 0 ? void 0 : _calls$filter$map.sort()) !== null && _calls$filter$map$sor !== void 0 ? _calls$filter$map$sor : []);\n  }, [calls]);\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys = JSON.parse(serializedCallKeys);\n    if (!chainId || callKeys.length === 0) return undefined;\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const calls = callKeys.map(key => parseCallKey(key));\n    dispatch(addMulticallListeners({\n      chainId,\n      calls,\n      options\n    }));\n    return () => {\n      dispatch(removeMulticallListeners({\n        chainId,\n        calls,\n        options\n      }));\n    };\n  }, [chainId, dispatch, options, serializedCallKeys]);\n  return useMemo(() => calls.map(call => {\n    var _callResults$chainId;\n    if (!chainId || !call) return INVALID_RESULT;\n    const result = (_callResults$chainId = callResults[chainId]) === null || _callResults$chainId === void 0 ? void 0 : _callResults$chainId[toCallKey(call)];\n    let data;\n    if (result !== null && result !== void 0 && result.data && (result === null || result === void 0 ? void 0 : result.data) !== '0x') {\n      // eslint-disable-next-line prefer-destructuring\n      data = result.data;\n    }\n    return {\n      valid: true,\n      data,\n      blockNumber: result === null || result === void 0 ? void 0 : result.blockNumber\n    };\n  }), [callResults, calls, chainId]);\n}\nconst INVALID_CALL_STATE = {\n  valid: false,\n  result: undefined,\n  loading: false,\n  syncing: false,\n  error: false\n};\nconst LOADING_CALL_STATE = {\n  valid: true,\n  result: undefined,\n  loading: true,\n  syncing: true,\n  error: false\n};\nfunction toCallState(callResult, contractInterface, fragment, latestBlockNumber) {\n  if (!callResult) return INVALID_CALL_STATE;\n  const {\n    valid,\n    data,\n    blockNumber\n  } = callResult;\n  if (!valid) return INVALID_CALL_STATE;\n  if (valid && !blockNumber) return LOADING_CALL_STATE;\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE;\n  const success = data && data.length > 2;\n  const syncing = (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0) < latestBlockNumber;\n  let result;\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data);\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data);\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result\n      };\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result,\n    error: !success\n  };\n}\nexport function useSingleContractMultipleData(contract, methodName, callInputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface = contract.interface) === null || _contract$interface === void 0 ? void 0 : _contract$interface.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => contract && fragment && callInputs && callInputs.length > 0 ? callInputs.map(inputs => {\n    return {\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    };\n  }) : [], [callInputs, contract, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber));\n  }, [fragment, contract, results, latestBlockNumber]);\n}\nexport function useMultipleContractSingleData(addresses, contractInterface, methodName, callInputs, options) {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName]);\n  const callData = useMemo(() => fragment && isValidMethodArgs(callInputs) ? contractInterface.encodeFunctionData(fragment, callInputs) : undefined, [callInputs, contractInterface, fragment]);\n  const calls = useMemo(() => fragment && addresses && addresses.length > 0 && callData ? addresses.map(address => {\n    return address && callData ? {\n      address,\n      callData\n    } : undefined;\n  }) : [], [addresses, callData, fragment]);\n  const results = useCallsData(calls, options);\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return results.map(result => toCallState(result, contractInterface, fragment, latestBlockNumber));\n  }, [fragment, results, contractInterface, latestBlockNumber]);\n}\nexport function useSingleCallResult(contract, methodName, inputs, options) {\n  const fragment = useMemo(() => {\n    var _contract$interface2;\n    return contract === null || contract === void 0 ? void 0 : (_contract$interface2 = contract.interface) === null || _contract$interface2 === void 0 ? void 0 : _contract$interface2.getFunction(methodName);\n  }, [contract, methodName]);\n  const calls = useMemo(() => {\n    return contract && fragment && isValidMethodArgs(inputs) ? [{\n      address: contract.address,\n      callData: contract.interface.encodeFunctionData(fragment, inputs)\n    }] : [];\n  }, [contract, fragment, inputs]);\n  const result = useCallsData(calls, options)[0];\n  const latestBlockNumber = useBlockNumber();\n  return useMemo(() => {\n    return toCallState(result, contract === null || contract === void 0 ? void 0 : contract.interface, fragment, latestBlockNumber);\n  }, [result, contract, fragment, latestBlockNumber]);\n}","map":{"version":3,"names":["useEffect","useMemo","useDispatch","useSelector","useActiveWeb3React","useBlockNumber","addMulticallListeners","removeMulticallListeners","parseCallKey","toCallKey","isMethodArg","x","indexOf","isValidMethodArgs","undefined","Array","isArray","every","xi","INVALID_RESULT","valid","blockNumber","data","NEVER_RELOAD","blocksPerFetch","Infinity","useCallsData","calls","options","chainId","callResults","state","multicall","dispatch","serializedCallKeys","JSON","stringify","filter","c","Boolean","map","sort","callKeys","parse","length","key","call","result","INVALID_CALL_STATE","loading","syncing","error","LOADING_CALL_STATE","toCallState","callResult","contractInterface","fragment","latestBlockNumber","success","decodeFunctionResult","console","debug","useSingleContractMultipleData","contract","methodName","callInputs","interface","getFunction","inputs","address","callData","encodeFunctionData","results","useMultipleContractSingleData","addresses","useSingleCallResult"],"sources":["/Users/namratapatel/upwork/SmartFinance-OmniDex/src/state/multicall/hooks.ts"],"sourcesContent":["import { Interface, FunctionFragment } from '@ethersproject/abi'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { useEffect, useMemo } from 'react'\nimport { useDispatch, useSelector } from 'react-redux'\nimport useActiveWeb3React from 'hooks/useActiveWeb3React'\nimport { useBlockNumber } from '../application/hooks'\nimport { AppDispatch, AppState } from '../index'\nimport {\n  addMulticallListeners,\n  Call,\n  removeMulticallListeners,\n  parseCallKey,\n  toCallKey,\n  ListenerOptions,\n} from './actions'\n\nexport interface Result extends ReadonlyArray<any> {\n  readonly [key: string]: any\n}\n\ntype MethodArg = string | number | BigNumber\ntype MethodArgs = Array<MethodArg | MethodArg[]>\n\ntype OptionalMethodInputs = Array<MethodArg | MethodArg[] | undefined> | undefined\n\nfunction isMethodArg(x: unknown): x is MethodArg {\n  return ['string', 'number'].indexOf(typeof x) !== -1\n}\n\nfunction isValidMethodArgs(x: unknown): x is MethodArgs | undefined {\n  return (\n    x === undefined ||\n    (Array.isArray(x) && x.every((xi) => isMethodArg(xi) || (Array.isArray(xi) && xi.every(isMethodArg))))\n  )\n}\n\ninterface CallResult {\n  readonly valid: boolean\n  readonly data: string | undefined\n  readonly blockNumber: number | undefined\n}\n\nconst INVALID_RESULT: CallResult = { valid: false, blockNumber: undefined, data: undefined }\n\n// use this options object\nexport const NEVER_RELOAD: ListenerOptions = {\n  blocksPerFetch: Infinity,\n}\n\n// the lowest level call for subscribing to contract data\nfunction useCallsData(calls: (Call | undefined)[], options?: ListenerOptions): CallResult[] {\n  const { chainId } = useActiveWeb3React()\n  const callResults = useSelector<AppState, AppState['multicall']['callResults']>(\n    (state) => state.multicall.callResults,\n  )\n  const dispatch = useDispatch<AppDispatch>()\n\n  const serializedCallKeys: string = useMemo(\n    () =>\n      JSON.stringify(\n        calls\n          ?.filter((c): c is Call => Boolean(c))\n          ?.map(toCallKey)\n          ?.sort() ?? [],\n      ),\n    [calls],\n  )\n\n  // update listeners when there is an actual change that persists for at least 100ms\n  useEffect(() => {\n    const callKeys: string[] = JSON.parse(serializedCallKeys)\n    if (!chainId || callKeys.length === 0) return undefined\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const calls = callKeys.map((key) => parseCallKey(key))\n    dispatch(\n      addMulticallListeners({\n        chainId,\n        calls,\n        options,\n      }),\n    )\n\n    return () => {\n      dispatch(\n        removeMulticallListeners({\n          chainId,\n          calls,\n          options,\n        }),\n      )\n    }\n  }, [chainId, dispatch, options, serializedCallKeys])\n\n  return useMemo(\n    () =>\n      calls.map<CallResult>((call) => {\n        if (!chainId || !call) return INVALID_RESULT\n\n        const result = callResults[chainId]?.[toCallKey(call)]\n        let data\n        if (result?.data && result?.data !== '0x') {\n          // eslint-disable-next-line prefer-destructuring\n          data = result.data\n        }\n\n        return { valid: true, data, blockNumber: result?.blockNumber }\n      }),\n    [callResults, calls, chainId],\n  )\n}\n\ninterface CallState {\n  readonly valid: boolean\n  // the result, or undefined if loading or errored/no data\n  readonly result: Result | undefined\n  // true if the result has never been fetched\n  readonly loading: boolean\n  // true if the result is not for the latest block\n  readonly syncing: boolean\n  // true if the call was made and is synced, but the return data is invalid\n  readonly error: boolean\n}\n\nconst INVALID_CALL_STATE: CallState = { valid: false, result: undefined, loading: false, syncing: false, error: false }\nconst LOADING_CALL_STATE: CallState = { valid: true, result: undefined, loading: true, syncing: true, error: false }\n\nfunction toCallState(\n  callResult: CallResult | undefined,\n  contractInterface: Interface | undefined,\n  fragment: FunctionFragment | undefined,\n  latestBlockNumber: number | undefined,\n): CallState {\n  if (!callResult) return INVALID_CALL_STATE\n  const { valid, data, blockNumber } = callResult\n  if (!valid) return INVALID_CALL_STATE\n  if (valid && !blockNumber) return LOADING_CALL_STATE\n  if (!contractInterface || !fragment || !latestBlockNumber) return LOADING_CALL_STATE\n  const success = data && data.length > 2\n  const syncing = (blockNumber ?? 0) < latestBlockNumber\n  let result: Result | undefined\n  if (success && data) {\n    try {\n      result = contractInterface.decodeFunctionResult(fragment, data)\n    } catch (error) {\n      console.debug('Result data parsing failed', fragment, data)\n      return {\n        valid: true,\n        loading: false,\n        error: true,\n        syncing,\n        result,\n      }\n    }\n  }\n  return {\n    valid: true,\n    loading: false,\n    syncing,\n    result,\n    error: !success,\n  }\n}\n\nexport function useSingleContractMultipleData(\n  contract: Contract | null | undefined,\n  methodName: string,\n  callInputs: OptionalMethodInputs[],\n  options?: ListenerOptions,\n): CallState[] {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo(\n    () =>\n      contract && fragment && callInputs && callInputs.length > 0\n        ? callInputs.map<Call>((inputs) => {\n            return {\n              address: contract.address,\n              callData: contract.interface.encodeFunctionData(fragment, inputs),\n            }\n          })\n        : [],\n    [callInputs, contract, fragment],\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contract?.interface, fragment, latestBlockNumber))\n  }, [fragment, contract, results, latestBlockNumber])\n}\n\nexport function useMultipleContractSingleData(\n  addresses: (string | undefined)[],\n  contractInterface: Interface,\n  methodName: string,\n  callInputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n): CallState[] {\n  const fragment = useMemo(() => contractInterface.getFunction(methodName), [contractInterface, methodName])\n  const callData: string | undefined = useMemo(\n    () =>\n      fragment && isValidMethodArgs(callInputs)\n        ? contractInterface.encodeFunctionData(fragment, callInputs)\n        : undefined,\n    [callInputs, contractInterface, fragment],\n  )\n\n  const calls = useMemo(\n    () =>\n      fragment && addresses && addresses.length > 0 && callData\n        ? addresses.map<Call | undefined>((address) => {\n            return address && callData\n              ? {\n                  address,\n                  callData,\n                }\n              : undefined\n          })\n        : [],\n    [addresses, callData, fragment],\n  )\n\n  const results = useCallsData(calls, options)\n\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return results.map((result) => toCallState(result, contractInterface, fragment, latestBlockNumber))\n  }, [fragment, results, contractInterface, latestBlockNumber])\n}\n\nexport function useSingleCallResult(\n  contract: Contract | null | undefined,\n  methodName: string,\n  inputs?: OptionalMethodInputs,\n  options?: ListenerOptions,\n): CallState {\n  const fragment = useMemo(() => contract?.interface?.getFunction(methodName), [contract, methodName])\n\n  const calls = useMemo<Call[]>(() => {\n    return contract && fragment && isValidMethodArgs(inputs)\n      ? [\n          {\n            address: contract.address,\n            callData: contract.interface.encodeFunctionData(fragment, inputs),\n          },\n        ]\n      : []\n  }, [contract, fragment, inputs])\n\n  const result = useCallsData(calls, options)[0]\n  const latestBlockNumber = useBlockNumber()\n\n  return useMemo(() => {\n    return toCallState(result, contract?.interface, fragment, latestBlockNumber)\n  }, [result, contract, fragment, latestBlockNumber])\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}